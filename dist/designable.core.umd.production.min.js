(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Designable = global.Designable || {}, global.Designable.Core = {})));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var AbstractCursorEvent = /** @class */ (function () {
        function AbstractCursorEvent(data) {
            this.data = data || {
                clientX: 0,
                clientY: 0,
                pageX: 0,
                pageY: 0,
                target: null,
                view: Designable.Shared.globalThisPolyfill,
            };
            this.transformCoordinates();
        }
        AbstractCursorEvent.prototype.transformCoordinates = function () {
            var _a;
            var frameElement = (((_a = this.data) === null || _a === void 0 ? void 0 : _a.view) || {}).frameElement;
            if (frameElement && this.data.view !== Designable.Shared.globalThisPolyfill) {
                var frameRect = frameElement.getBoundingClientRect();
                var scale = frameRect.width / frameElement['offsetWidth'];
                this.data.topClientX = this.data.clientX * scale + frameRect.x;
                this.data.topClientY = this.data.clientY * scale + frameRect.y;
                this.data.topPageX =
                    this.data.pageX + frameRect.x - this.data.view.scrollX;
                this.data.topPageY =
                    this.data.pageY + frameRect.y - this.data.view.scrollY;
                var topElement = document.elementFromPoint(this.data.topPageX, this.data.topClientY);
                if (topElement !== frameElement) {
                    this.data.target = topElement;
                }
            }
            else {
                this.data.topClientX = this.data.clientX;
                this.data.topClientY = this.data.clientY;
                this.data.topPageX = this.data.pageX;
                this.data.topPageY = this.data.pageY;
            }
        };
        return AbstractCursorEvent;
    }());

    var DragMoveEvent = /** @class */ (function (_super) {
        __extends(DragMoveEvent, _super);
        function DragMoveEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'drag:move';
            return _this;
        }
        return DragMoveEvent;
    }(AbstractCursorEvent));

    var DragStartEvent = /** @class */ (function (_super) {
        __extends(DragStartEvent, _super);
        function DragStartEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'drag:start';
            return _this;
        }
        return DragStartEvent;
    }(AbstractCursorEvent));

    var DragStopEvent = /** @class */ (function (_super) {
        __extends(DragStopEvent, _super);
        function DragStopEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'drag:stop';
            return _this;
        }
        return DragStopEvent;
    }(AbstractCursorEvent));

    var MouseClickEvent = /** @class */ (function (_super) {
        __extends(MouseClickEvent, _super);
        function MouseClickEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'mouse:click';
            return _this;
        }
        return MouseClickEvent;
    }(AbstractCursorEvent));
    var MouseDoubleClickEvent = /** @class */ (function (_super) {
        __extends(MouseDoubleClickEvent, _super);
        function MouseDoubleClickEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'mouse:dblclick';
            return _this;
        }
        return MouseDoubleClickEvent;
    }(AbstractCursorEvent));

    var MouseMoveEvent = /** @class */ (function (_super) {
        __extends(MouseMoveEvent, _super);
        function MouseMoveEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'mouse:move';
            return _this;
        }
        return MouseMoveEvent;
    }(AbstractCursorEvent));

    var AbstractKeyboardEvent = /** @class */ (function () {
        function AbstractKeyboardEvent(e) {
            this.data = Designable.Shared.getKeyCodeFromEvent(e);
            this.originEvent = e;
        }
        Object.defineProperty(AbstractKeyboardEvent.prototype, "eventType", {
            get: function () {
                return this.originEvent.type;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractKeyboardEvent.prototype, "ctrlKey", {
            get: function () {
                return this.originEvent.ctrlKey;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractKeyboardEvent.prototype, "shiftKey", {
            get: function () {
                return this.originEvent.shiftKey;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractKeyboardEvent.prototype, "metaKey", {
            get: function () {
                return this.originEvent.metaKey;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractKeyboardEvent.prototype, "altkey", {
            get: function () {
                return this.originEvent.altKey;
            },
            enumerable: false,
            configurable: true
        });
        AbstractKeyboardEvent.prototype.preventDefault = function () {
            if (this.originEvent.preventDefault) {
                this.originEvent.preventDefault();
            }
            else {
                this.originEvent.returnValue = false;
            }
        };
        AbstractKeyboardEvent.prototype.stopPropagation = function () {
            var _a;
            if ((_a = this.originEvent) === null || _a === void 0 ? void 0 : _a.stopPropagation) {
                this.originEvent.stopPropagation();
            }
            else {
                this.originEvent.cancelBubble = true;
            }
        };
        return AbstractKeyboardEvent;
    }());

    var KeyDownEvent = /** @class */ (function (_super) {
        __extends(KeyDownEvent, _super);
        function KeyDownEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'key:down';
            return _this;
        }
        return KeyDownEvent;
    }(AbstractKeyboardEvent));

    var KeyUpEvent = /** @class */ (function (_super) {
        __extends(KeyUpEvent, _super);
        function KeyUpEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'key:up';
            return _this;
        }
        return KeyUpEvent;
    }(AbstractKeyboardEvent));

    var AbstractMutationNodeEvent = /** @class */ (function () {
        function AbstractMutationNodeEvent(data) {
            this.data = data;
        }
        return AbstractMutationNodeEvent;
    }());

    var DragNodeEvent = /** @class */ (function (_super) {
        __extends(DragNodeEvent, _super);
        function DragNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'drag:node';
            return _this;
        }
        return DragNodeEvent;
    }(AbstractMutationNodeEvent));

    var DropNodeEvent = /** @class */ (function (_super) {
        __extends(DropNodeEvent, _super);
        function DropNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'drop:node';
            return _this;
        }
        return DropNodeEvent;
    }(AbstractMutationNodeEvent));

    var HoverNodeEvent = /** @class */ (function (_super) {
        __extends(HoverNodeEvent, _super);
        function HoverNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'hover:node';
            return _this;
        }
        return HoverNodeEvent;
    }(AbstractMutationNodeEvent));

    var InsertAfterEvent = /** @class */ (function (_super) {
        __extends(InsertAfterEvent, _super);
        function InsertAfterEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'insert:after';
            return _this;
        }
        return InsertAfterEvent;
    }(AbstractMutationNodeEvent));

    var InsertBeforeEvent = /** @class */ (function (_super) {
        __extends(InsertBeforeEvent, _super);
        function InsertBeforeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'insert:before';
            return _this;
        }
        return InsertBeforeEvent;
    }(AbstractMutationNodeEvent));

    var InsertChildrenEvent = /** @class */ (function (_super) {
        __extends(InsertChildrenEvent, _super);
        function InsertChildrenEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'insert:children';
            return _this;
        }
        return InsertChildrenEvent;
    }(AbstractMutationNodeEvent));

    var PrependNodeEvent = /** @class */ (function (_super) {
        __extends(PrependNodeEvent, _super);
        function PrependNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'prepend:node';
            return _this;
        }
        return PrependNodeEvent;
    }(AbstractMutationNodeEvent));

    var RemoveNodeEvent = /** @class */ (function (_super) {
        __extends(RemoveNodeEvent, _super);
        function RemoveNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'remove:node';
            return _this;
        }
        return RemoveNodeEvent;
    }(AbstractMutationNodeEvent));

    var SelectNodeEvent = /** @class */ (function (_super) {
        __extends(SelectNodeEvent, _super);
        function SelectNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'select:node';
            return _this;
        }
        return SelectNodeEvent;
    }(AbstractMutationNodeEvent));

    var UnSelectNodeEvent = /** @class */ (function (_super) {
        __extends(UnSelectNodeEvent, _super);
        function UnSelectNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'unselect:node';
            return _this;
        }
        return UnSelectNodeEvent;
    }(AbstractMutationNodeEvent));

    var UpdateChildrenEvent = /** @class */ (function (_super) {
        __extends(UpdateChildrenEvent, _super);
        function UpdateChildrenEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'update:children';
            return _this;
        }
        return UpdateChildrenEvent;
    }(AbstractMutationNodeEvent));

    var UpdateNodePropsEvent = /** @class */ (function (_super) {
        __extends(UpdateNodePropsEvent, _super);
        function UpdateNodePropsEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'update:node:props';
            return _this;
        }
        return UpdateNodePropsEvent;
    }(AbstractMutationNodeEvent));

    var WrapNodeEvent = /** @class */ (function (_super) {
        __extends(WrapNodeEvent, _super);
        function WrapNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'wrap:node';
            return _this;
        }
        return WrapNodeEvent;
    }(AbstractMutationNodeEvent));

    var CloneNodeEvent = /** @class */ (function (_super) {
        __extends(CloneNodeEvent, _super);
        function CloneNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'clone:node';
            return _this;
        }
        return CloneNodeEvent;
    }(AbstractMutationNodeEvent));

    var AppendNodeEvent = /** @class */ (function (_super) {
        __extends(AppendNodeEvent, _super);
        function AppendNodeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'append:node';
            return _this;
        }
        return AppendNodeEvent;
    }(AbstractMutationNodeEvent));

    var FromNodeEvent = /** @class */ (function () {
        function FromNodeEvent(data) {
            this.type = 'from:node';
            this.data = data;
        }
        return FromNodeEvent;
    }());

    var AbstractViewportEvent = /** @class */ (function () {
        function AbstractViewportEvent(data) {
            this.data = data || {
                scrollX: Designable.Shared.globalThisPolyfill.scrollX,
                scrollY: Designable.Shared.globalThisPolyfill.scrollY,
                width: Designable.Shared.globalThisPolyfill.innerWidth,
                height: Designable.Shared.globalThisPolyfill.innerHeight,
                innerWidth: Designable.Shared.globalThisPolyfill.innerWidth,
                innerHeight: Designable.Shared.globalThisPolyfill.innerHeight,
                view: Designable.Shared.globalThisPolyfill,
                target: Designable.Shared.globalThisPolyfill,
            };
        }
        return AbstractViewportEvent;
    }());

    var ViewportResizeEvent = /** @class */ (function (_super) {
        __extends(ViewportResizeEvent, _super);
        function ViewportResizeEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'viewport:resize';
            return _this;
        }
        return ViewportResizeEvent;
    }(AbstractViewportEvent));

    var ViewportScrollEvent = /** @class */ (function (_super) {
        __extends(ViewportScrollEvent, _super);
        function ViewportScrollEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'viewport:scroll';
            return _this;
        }
        return ViewportScrollEvent;
    }(AbstractViewportEvent));

    var AbstractWorkspaceEvent = /** @class */ (function () {
        function AbstractWorkspaceEvent(data) {
            this.data = data;
        }
        return AbstractWorkspaceEvent;
    }());

    var AddWorkspaceEvent = /** @class */ (function (_super) {
        __extends(AddWorkspaceEvent, _super);
        function AddWorkspaceEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'add:workspace';
            return _this;
        }
        return AddWorkspaceEvent;
    }(AbstractWorkspaceEvent));

    var RemoveWorkspaceEvent = /** @class */ (function (_super) {
        __extends(RemoveWorkspaceEvent, _super);
        function RemoveWorkspaceEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'remove:workspace';
            return _this;
        }
        return RemoveWorkspaceEvent;
    }(AbstractWorkspaceEvent));

    var SwitchWorkspaceEvent = /** @class */ (function (_super) {
        __extends(SwitchWorkspaceEvent, _super);
        function SwitchWorkspaceEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'switch:workspace';
            return _this;
        }
        return SwitchWorkspaceEvent;
    }(AbstractWorkspaceEvent));

    var AbstractHistoryEvent = /** @class */ (function () {
        function AbstractHistoryEvent(data) {
            this.data = data;
        }
        return AbstractHistoryEvent;
    }());

    var HistoryUndoEvent = /** @class */ (function (_super) {
        __extends(HistoryUndoEvent, _super);
        function HistoryUndoEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'history:undo';
            return _this;
        }
        return HistoryUndoEvent;
    }(AbstractHistoryEvent));

    var HistoryRedoEvent = /** @class */ (function (_super) {
        __extends(HistoryRedoEvent, _super);
        function HistoryRedoEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'history:redo';
            return _this;
        }
        return HistoryRedoEvent;
    }(AbstractHistoryEvent));

    var HistoryGotoEvent = /** @class */ (function (_super) {
        __extends(HistoryGotoEvent, _super);
        function HistoryGotoEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'history:goto';
            return _this;
        }
        return HistoryGotoEvent;
    }(AbstractHistoryEvent));

    var HistoryPushEvent = /** @class */ (function (_super) {
        __extends(HistoryPushEvent, _super);
        function HistoryPushEvent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'history:push';
            return _this;
        }
        return HistoryPushEvent;
    }(AbstractHistoryEvent));

    var GlobalState = {
        dragging: false,
        onMouseDownAt: 0,
        startEvent: null,
        moveEvent: null,
    };
    var DragDropDriver = /** @class */ (function (_super) {
        __extends(DragDropDriver, _super);
        function DragDropDriver() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.mouseDownTimer = null;
            _this.onMouseDown = function (e) {
                var _a, _b;
                if (e.button !== 0 || e.ctrlKey || e.metaKey) {
                    return;
                }
                if (e.target['isContentEditable'] ||
                    e.target['contentEditable'] === 'true') {
                    return true;
                }
                if ((_b = (_a = e.target) === null || _a === void 0 ? void 0 : _a['closest']) === null || _b === void 0 ? void 0 : _b.call(_a, '.monaco-editor'))
                    return;
                GlobalState.startEvent = e;
                GlobalState.dragging = false;
                GlobalState.onMouseDownAt = Date.now();
                _this.batchAddEventListener('mouseup', _this.onMouseUp);
                _this.batchAddEventListener('dragend', _this.onMouseUp);
                _this.batchAddEventListener('dragstart', _this.onStartDrag);
                _this.batchAddEventListener('mousemove', _this.onDistanceChange);
            };
            _this.onMouseUp = function (e) {
                if (GlobalState.dragging) {
                    _this.dispatch(new DragStopEvent({
                        clientX: e.clientX,
                        clientY: e.clientY,
                        pageX: e.pageX,
                        pageY: e.pageY,
                        target: e.target,
                        view: e.view,
                    }));
                }
                _this.batchRemoveEventListener('contextmenu', _this.onContextMenuWhileDragging, true);
                _this.batchRemoveEventListener('mouseup', _this.onMouseUp);
                _this.batchRemoveEventListener('mousedown', _this.onMouseDown);
                _this.batchRemoveEventListener('dragover', _this.onMouseMove);
                _this.batchRemoveEventListener('mousemove', _this.onMouseMove);
                _this.batchRemoveEventListener('mousemove', _this.onDistanceChange);
                GlobalState.dragging = false;
            };
            _this.onMouseMove = function (e) {
                var _a, _b;
                if (e.clientX === ((_a = GlobalState.moveEvent) === null || _a === void 0 ? void 0 : _a.clientX) &&
                    e.clientY === ((_b = GlobalState.moveEvent) === null || _b === void 0 ? void 0 : _b.clientY))
                    return;
                _this.dispatch(new DragMoveEvent({
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY,
                    target: e.target,
                    view: e.view,
                }));
                GlobalState.moveEvent = e;
            };
            _this.onContextMenuWhileDragging = function (e) {
                e.preventDefault();
            };
            _this.onStartDrag = function (e) {
                if (GlobalState.dragging)
                    return;
                GlobalState.startEvent = GlobalState.startEvent || e;
                _this.batchAddEventListener('dragover', _this.onMouseMove);
                _this.batchAddEventListener('mousemove', _this.onMouseMove);
                _this.batchAddEventListener('contextmenu', _this.onContextMenuWhileDragging, true);
                _this.dispatch(new DragStartEvent({
                    clientX: GlobalState.startEvent.clientX,
                    clientY: GlobalState.startEvent.clientY,
                    pageX: GlobalState.startEvent.pageX,
                    pageY: GlobalState.startEvent.pageY,
                    target: GlobalState.startEvent.target,
                    view: GlobalState.startEvent.view,
                }));
                GlobalState.dragging = true;
            };
            _this.onDistanceChange = function (e) {
                var distance = Math.sqrt(Math.pow(e.pageX - GlobalState.startEvent.pageX, 2) +
                    Math.pow(e.pageY - GlobalState.startEvent.pageY, 2));
                var timeDelta = Date.now() - GlobalState.onMouseDownAt;
                if (timeDelta > 10 && e !== GlobalState.startEvent && distance > 4) {
                    _this.batchRemoveEventListener('mousemove', _this.onDistanceChange);
                    _this.onStartDrag(e);
                }
            };
            return _this;
        }
        DragDropDriver.prototype.attach = function () {
            this.batchAddEventListener('mousedown', this.onMouseDown, true);
        };
        DragDropDriver.prototype.detach = function () {
            GlobalState.dragging = false;
            GlobalState.moveEvent = null;
            GlobalState.onMouseDownAt = null;
            GlobalState.startEvent = null;
            this.batchRemoveEventListener('mousedown', this.onMouseDown, true);
            this.batchRemoveEventListener('dragstart', this.onStartDrag);
            this.batchRemoveEventListener('dragend', this.onMouseUp);
            this.batchRemoveEventListener('dragover', this.onMouseMove);
            this.batchRemoveEventListener('mouseup', this.onMouseUp);
            this.batchRemoveEventListener('mousemove', this.onMouseMove);
            this.batchRemoveEventListener('mousemove', this.onDistanceChange);
            this.batchRemoveEventListener('contextmenu', this.onContextMenuWhileDragging, true);
        };
        return DragDropDriver;
    }(Designable.Shared.EventDriver));

    var MouseClickDriver = /** @class */ (function (_super) {
        __extends(MouseClickDriver, _super);
        function MouseClickDriver() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.onMouseClick = function (e) {
                var target = e.target;
                if (target === null || target === void 0 ? void 0 : target.closest("*[" + _this.engine.props.clickStopPropagationAttrName + "]")) {
                    return;
                }
                _this.dispatch(new MouseClickEvent({
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY,
                    target: e.target,
                    view: e.view,
                }));
            };
            _this.onMouseDoubleClick = function (e) {
                var target = e.target;
                if (target === null || target === void 0 ? void 0 : target.closest("*[" + _this.engine.props.clickStopPropagationAttrName + "]")) {
                    return;
                }
                _this.dispatch(new MouseDoubleClickEvent({
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY,
                    target: e.target,
                    view: e.view,
                }));
            };
            return _this;
        }
        MouseClickDriver.prototype.attach = function () {
            this.addEventListener('click', this.onMouseClick, {
                mode: 'onlyChild',
            });
            this.addEventListener('dblclick', this.onMouseDoubleClick, {
                mode: 'onlyChild',
            });
        };
        MouseClickDriver.prototype.detach = function () {
            this.removeEventListener('click', this.onMouseClick, {
                mode: 'onlyChild',
            });
            this.removeEventListener('dblclick', this.onMouseDoubleClick, {
                mode: 'onlyChild',
            });
        };
        return MouseClickDriver;
    }(Designable.Shared.EventDriver));

    var MouseMoveDriver = /** @class */ (function (_super) {
        __extends(MouseMoveDriver, _super);
        function MouseMoveDriver() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.request = null;
            _this.onMouseMove = function (e) {
                _this.request = requestAnimationFrame(function () {
                    cancelAnimationFrame(_this.request);
                    _this.dispatch(new MouseMoveEvent({
                        clientX: e.clientX,
                        clientY: e.clientY,
                        pageX: e.pageX,
                        pageY: e.pageY,
                        target: e.target,
                        view: e.view,
                    }));
                });
            };
            return _this;
        }
        MouseMoveDriver.prototype.attach = function () {
            this.addEventListener('mousemove', this.onMouseMove, {
                mode: 'onlyOne',
            });
        };
        MouseMoveDriver.prototype.detach = function () {
            this.removeEventListener('mouseover', this.onMouseMove, {
                mode: 'onlyOne',
            });
        };
        return MouseMoveDriver;
    }(Designable.Shared.EventDriver));

    var resizeObservers = [];

    var hasActiveObservations = function () {
        return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });
    };

    var hasSkippedObservations = function () {
        return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });
    };

    var msg = 'ResizeObserver loop completed with undelivered notifications.';
    var deliverResizeLoopError = function () {
        var event;
        if (typeof ErrorEvent === 'function') {
            event = new ErrorEvent('error', {
                message: msg
            });
        }
        else {
            event = document.createEvent('Event');
            event.initEvent('error', false, false);
            event.message = msg;
        }
        window.dispatchEvent(event);
    };

    var ResizeObserverBoxOptions;
    (function (ResizeObserverBoxOptions) {
        ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
        ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
        ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

    var freeze = function (obj) { return Object.freeze(obj); };

    var ResizeObserverSize = (function () {
        function ResizeObserverSize(inlineSize, blockSize) {
            this.inlineSize = inlineSize;
            this.blockSize = blockSize;
            freeze(this);
        }
        return ResizeObserverSize;
    }());

    var DOMRectReadOnly = (function () {
        function DOMRectReadOnly(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.top = this.y;
            this.left = this.x;
            this.bottom = this.top + this.height;
            this.right = this.left + this.width;
            return freeze(this);
        }
        DOMRectReadOnly.prototype.toJSON = function () {
            var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
            return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };
        };
        DOMRectReadOnly.fromRect = function (rectangle) {
            return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
        };
        return DOMRectReadOnly;
    }());

    var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };
    var isHidden = function (target) {
        if (isSVG(target)) {
            var _a = target.getBBox(), width = _a.width, height = _a.height;
            return !width && !height;
        }
        var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
        return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    var isElement = function (obj) {
        var _a, _b;
        if (obj instanceof Element) {
            return true;
        }
        var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
        return !!(scope && obj instanceof scope.Element);
    };
    var isReplacedElement = function (target) {
        switch (target.tagName) {
            case 'INPUT':
                if (target.type !== 'image') {
                    break;
                }
            case 'VIDEO':
            case 'AUDIO':
            case 'EMBED':
            case 'OBJECT':
            case 'CANVAS':
            case 'IFRAME':
            case 'IMG':
                return true;
        }
        return false;
    };

    var global = typeof window !== 'undefined' ? window : {};

    var cache = new WeakMap();
    var scrollRegexp = /auto|scroll/;
    var verticalRegexp = /^tb|vertical/;
    var IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);
    var parseDimension = function (pixel) { return parseFloat(pixel || '0'); };
    var size = function (inlineSize, blockSize, switchSizes) {
        if (inlineSize === void 0) { inlineSize = 0; }
        if (blockSize === void 0) { blockSize = 0; }
        if (switchSizes === void 0) { switchSizes = false; }
        return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    var zeroBoxes = freeze({
        devicePixelContentBoxSize: size(),
        borderBoxSize: size(),
        contentBoxSize: size(),
        contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    var calculateBoxSizes = function (target, forceRecalculation) {
        if (forceRecalculation === void 0) { forceRecalculation = false; }
        if (cache.has(target) && !forceRecalculation) {
            return cache.get(target);
        }
        if (isHidden(target)) {
            cache.set(target, zeroBoxes);
            return zeroBoxes;
        }
        var cs = getComputedStyle(target);
        var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
        var removePadding = !IE && cs.boxSizing === 'border-box';
        var switchSizes = verticalRegexp.test(cs.writingMode || '');
        var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
        var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
        var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
        var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
        var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
        var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
        var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
        var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
        var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
        var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
        var horizontalPadding = paddingLeft + paddingRight;
        var verticalPadding = paddingTop + paddingBottom;
        var horizontalBorderArea = borderLeft + borderRight;
        var verticalBorderArea = borderTop + borderBottom;
        var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
        var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
        var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
        var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
        var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
        var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
        var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
        var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
        var boxes = freeze({
            devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
            borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
            contentBoxSize: size(contentWidth, contentHeight, switchSizes),
            contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
        });
        cache.set(target, boxes);
        return boxes;
    };
    var calculateBoxSize = function (target, observedBox, forceRecalculation) {
        var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
        switch (observedBox) {
            case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
                return devicePixelContentBoxSize;
            case ResizeObserverBoxOptions.BORDER_BOX:
                return borderBoxSize;
            default:
                return contentBoxSize;
        }
    };

    var ResizeObserverEntry = (function () {
        function ResizeObserverEntry(target) {
            var boxes = calculateBoxSizes(target);
            this.target = target;
            this.contentRect = boxes.contentRect;
            this.borderBoxSize = freeze([boxes.borderBoxSize]);
            this.contentBoxSize = freeze([boxes.contentBoxSize]);
            this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
        }
        return ResizeObserverEntry;
    }());

    var calculateDepthForNode = function (node) {
        if (isHidden(node)) {
            return Infinity;
        }
        var depth = 0;
        var parent = node.parentNode;
        while (parent) {
            depth += 1;
            parent = parent.parentNode;
        }
        return depth;
    };

    var broadcastActiveObservations = function () {
        var shallowestDepth = Infinity;
        var callbacks = [];
        resizeObservers.forEach(function processObserver(ro) {
            if (ro.activeTargets.length === 0) {
                return;
            }
            var entries = [];
            ro.activeTargets.forEach(function processTarget(ot) {
                var entry = new ResizeObserverEntry(ot.target);
                var targetDepth = calculateDepthForNode(ot.target);
                entries.push(entry);
                ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
                if (targetDepth < shallowestDepth) {
                    shallowestDepth = targetDepth;
                }
            });
            callbacks.push(function resizeObserverCallback() {
                ro.callback.call(ro.observer, entries, ro.observer);
            });
            ro.activeTargets.splice(0, ro.activeTargets.length);
        });
        for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
            var callback = callbacks_1[_i];
            callback();
        }
        return shallowestDepth;
    };

    var gatherActiveObservationsAtDepth = function (depth) {
        resizeObservers.forEach(function processObserver(ro) {
            ro.activeTargets.splice(0, ro.activeTargets.length);
            ro.skippedTargets.splice(0, ro.skippedTargets.length);
            ro.observationTargets.forEach(function processTarget(ot) {
                if (ot.isActive()) {
                    if (calculateDepthForNode(ot.target) > depth) {
                        ro.activeTargets.push(ot);
                    }
                    else {
                        ro.skippedTargets.push(ot);
                    }
                }
            });
        });
    };

    var process = function () {
        var depth = 0;
        gatherActiveObservationsAtDepth(depth);
        while (hasActiveObservations()) {
            depth = broadcastActiveObservations();
            gatherActiveObservationsAtDepth(depth);
        }
        if (hasSkippedObservations()) {
            deliverResizeLoopError();
        }
        return depth > 0;
    };

    var trigger;
    var callbacks = [];
    var notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };
    var queueMicroTask = function (callback) {
        if (!trigger) {
            var toggle_1 = 0;
            var el_1 = document.createTextNode('');
            var config = { characterData: true };
            new MutationObserver(function () { return notify(); }).observe(el_1, config);
            trigger = function () { el_1.textContent = "" + (toggle_1 ? toggle_1-- : toggle_1++); };
        }
        callbacks.push(callback);
        trigger();
    };

    var queueResizeObserver = function (cb) {
        queueMicroTask(function ResizeObserver() {
            requestAnimationFrame(cb);
        });
    };

    var watching = 0;
    var isWatching = function () { return !!watching; };
    var CATCH_PERIOD = 250;
    var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    var events = [
        'resize',
        'load',
        'transitionend',
        'animationend',
        'animationstart',
        'animationiteration',
        'keyup',
        'keydown',
        'mouseup',
        'mousedown',
        'mouseover',
        'mouseout',
        'blur',
        'focus'
    ];
    var time = function (timeout) {
        if (timeout === void 0) { timeout = 0; }
        return Date.now() + timeout;
    };
    var scheduled = false;
    var Scheduler = (function () {
        function Scheduler() {
            var _this = this;
            this.stopped = true;
            this.listener = function () { return _this.schedule(); };
        }
        Scheduler.prototype.run = function (timeout) {
            var _this = this;
            if (timeout === void 0) { timeout = CATCH_PERIOD; }
            if (scheduled) {
                return;
            }
            scheduled = true;
            var until = time(timeout);
            queueResizeObserver(function () {
                var elementsHaveResized = false;
                try {
                    elementsHaveResized = process();
                }
                finally {
                    scheduled = false;
                    timeout = until - time();
                    if (!isWatching()) {
                        return;
                    }
                    if (elementsHaveResized) {
                        _this.run(1000);
                    }
                    else if (timeout > 0) {
                        _this.run(timeout);
                    }
                    else {
                        _this.start();
                    }
                }
            });
        };
        Scheduler.prototype.schedule = function () {
            this.stop();
            this.run();
        };
        Scheduler.prototype.observe = function () {
            var _this = this;
            var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };
            document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);
        };
        Scheduler.prototype.start = function () {
            var _this = this;
            if (this.stopped) {
                this.stopped = false;
                this.observer = new MutationObserver(this.listener);
                this.observe();
                events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });
            }
        };
        Scheduler.prototype.stop = function () {
            var _this = this;
            if (!this.stopped) {
                this.observer && this.observer.disconnect();
                events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });
                this.stopped = true;
            }
        };
        return Scheduler;
    }());
    var scheduler = new Scheduler();
    var updateCount = function (n) {
        !watching && n > 0 && scheduler.start();
        watching += n;
        !watching && scheduler.stop();
    };

    var skipNotifyOnElement = function (target) {
        return !isSVG(target)
            && !isReplacedElement(target)
            && getComputedStyle(target).display === 'inline';
    };
    var ResizeObservation = (function () {
        function ResizeObservation(target, observedBox) {
            this.target = target;
            this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
            this.lastReportedSize = {
                inlineSize: 0,
                blockSize: 0
            };
        }
        ResizeObservation.prototype.isActive = function () {
            var size = calculateBoxSize(this.target, this.observedBox, true);
            if (skipNotifyOnElement(this.target)) {
                this.lastReportedSize = size;
            }
            if (this.lastReportedSize.inlineSize !== size.inlineSize
                || this.lastReportedSize.blockSize !== size.blockSize) {
                return true;
            }
            return false;
        };
        return ResizeObservation;
    }());

    var ResizeObserverDetail = (function () {
        function ResizeObserverDetail(resizeObserver, callback) {
            this.activeTargets = [];
            this.skippedTargets = [];
            this.observationTargets = [];
            this.observer = resizeObserver;
            this.callback = callback;
        }
        return ResizeObserverDetail;
    }());

    var observerMap = new WeakMap();
    var getObservationIndex = function (observationTargets, target) {
        for (var i = 0; i < observationTargets.length; i += 1) {
            if (observationTargets[i].target === target) {
                return i;
            }
        }
        return -1;
    };
    var ResizeObserverController = (function () {
        function ResizeObserverController() {
        }
        ResizeObserverController.connect = function (resizeObserver, callback) {
            var detail = new ResizeObserverDetail(resizeObserver, callback);
            observerMap.set(resizeObserver, detail);
        };
        ResizeObserverController.observe = function (resizeObserver, target, options) {
            var detail = observerMap.get(resizeObserver);
            var firstObservation = detail.observationTargets.length === 0;
            if (getObservationIndex(detail.observationTargets, target) < 0) {
                firstObservation && resizeObservers.push(detail);
                detail.observationTargets.push(new ResizeObservation(target, options && options.box));
                updateCount(1);
                scheduler.schedule();
            }
        };
        ResizeObserverController.unobserve = function (resizeObserver, target) {
            var detail = observerMap.get(resizeObserver);
            var index = getObservationIndex(detail.observationTargets, target);
            var lastObservation = detail.observationTargets.length === 1;
            if (index >= 0) {
                lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
                detail.observationTargets.splice(index, 1);
                updateCount(-1);
            }
        };
        ResizeObserverController.disconnect = function (resizeObserver) {
            var _this = this;
            var detail = observerMap.get(resizeObserver);
            detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });
            detail.activeTargets.splice(0, detail.activeTargets.length);
        };
        return ResizeObserverController;
    }());

    var ResizeObserver = (function () {
        function ResizeObserver(callback) {
            if (arguments.length === 0) {
                throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
            }
            if (typeof callback !== 'function') {
                throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
            }
            ResizeObserverController.connect(this, callback);
        }
        ResizeObserver.prototype.observe = function (target, options) {
            if (arguments.length === 0) {
                throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
            }
            if (!isElement(target)) {
                throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
            }
            ResizeObserverController.observe(this, target, options);
        };
        ResizeObserver.prototype.unobserve = function (target) {
            if (arguments.length === 0) {
                throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
            }
            if (!isElement(target)) {
                throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
            }
            ResizeObserverController.unobserve(this, target);
        };
        ResizeObserver.prototype.disconnect = function () {
            ResizeObserverController.disconnect(this);
        };
        ResizeObserver.toString = function () {
            return 'function ResizeObserver () { [polyfill code] }';
        };
        return ResizeObserver;
    }());

    var ViewportResizeDriver = /** @class */ (function (_super) {
        __extends(ViewportResizeDriver, _super);
        function ViewportResizeDriver() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.request = null;
            _this.resizeObserver = null;
            _this.onResize = function (e) {
                if (e.preventDefault)
                    e.preventDefault();
                _this.request = requestAnimationFrame(function () {
                    cancelAnimationFrame(_this.request);
                    _this.dispatch(new ViewportResizeEvent({
                        scrollX: _this.contentWindow.scrollX,
                        scrollY: _this.contentWindow.scrollY,
                        width: _this.contentWindow.innerWidth,
                        height: _this.contentWindow.innerHeight,
                        innerHeight: _this.contentWindow.innerHeight,
                        innerWidth: _this.contentWindow.innerWidth,
                        view: _this.contentWindow,
                        target: e.target || _this.container,
                    }));
                });
            };
            return _this;
        }
        ViewportResizeDriver.prototype.attach = function () {
            if (this.contentWindow && this.contentWindow !== Designable.Shared.globalThisPolyfill) {
                this.addEventListener('resize', this.onResize);
            }
            else {
                if (this.container && this.container !== document) {
                    this.resizeObserver = new ResizeObserver(this.onResize);
                    this.resizeObserver.observe(this.container);
                }
            }
        };
        ViewportResizeDriver.prototype.detach = function () {
            if (this.contentWindow && this.contentWindow !== Designable.Shared.globalThisPolyfill) {
                this.removeEventListener('resize', this.onResize);
            }
            else if (this.resizeObserver) {
                if (this.container && this.container !== document) {
                    this.resizeObserver.unobserve(this.container);
                    this.resizeObserver.disconnect();
                }
            }
        };
        return ViewportResizeDriver;
    }(Designable.Shared.EventDriver));

    var ViewportScrollDriver = /** @class */ (function (_super) {
        __extends(ViewportScrollDriver, _super);
        function ViewportScrollDriver() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.request = null;
            _this.onScroll = function (e) {
                e.preventDefault();
                _this.request = Designable.Shared.globalThisPolyfill.requestAnimationFrame(function () {
                    _this.dispatch(new ViewportScrollEvent({
                        scrollX: _this.contentWindow.scrollX,
                        scrollY: _this.contentWindow.scrollY,
                        width: _this.contentWindow.document.body.clientWidth,
                        height: _this.contentWindow.document.body.clientHeight,
                        innerHeight: _this.contentWindow.innerHeight,
                        innerWidth: _this.contentWindow.innerWidth,
                        view: _this.contentWindow,
                        target: e.target,
                    }));
                    cancelAnimationFrame(_this.request);
                });
            };
            return _this;
        }
        ViewportScrollDriver.prototype.attach = function () {
            this.addEventListener('scroll', this.onScroll);
        };
        ViewportScrollDriver.prototype.detach = function () {
            this.removeEventListener('scroll', this.onScroll);
        };
        return ViewportScrollDriver;
    }(Designable.Shared.EventDriver));

    function filter(event) {
        var target = event.target;
        var tagName = target.tagName;
        var flag = true;
        // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>Web Components
        if (target['isContentEditable'] ||
            ((tagName === 'INPUT' ||
                tagName === 'TEXTAREA' ||
                tagName === 'SELECT' ||
                customElements.get(tagName.toLocaleLowerCase())) &&
                !target.readOnly)) {
            flag = false;
        }
        return flag;
    }
    var KeyboardDriver = /** @class */ (function (_super) {
        __extends(KeyboardDriver, _super);
        function KeyboardDriver() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.onKeyDown = function (e) {
                if (!filter(e))
                    return;
                _this.dispatch(new KeyDownEvent(e));
            };
            _this.onKeyUp = function (e) {
                _this.dispatch(new KeyUpEvent(e));
            };
            return _this;
        }
        KeyboardDriver.prototype.attach = function () {
            this.addEventListener('keydown', this.onKeyDown, {
                mode: 'onlyParent',
            });
            this.addEventListener('keyup', this.onKeyUp, {
                mode: 'onlyParent',
            });
        };
        KeyboardDriver.prototype.detach = function () {
            this.removeEventListener('keydown', this.onKeyDown, {
                mode: 'onlyParent',
            });
            this.removeEventListener('keyup', this.onKeyUp, {
                mode: 'onlyParent',
            });
        };
        return KeyboardDriver;
    }(Designable.Shared.EventDriver));

    var lowerSnake = function (str) {
        return String(str).replace(/\s+/g, '_').toLocaleLowerCase();
    };
    var mergeLocales = function (target, source) {
        if (Designable.Shared.isPlainObj(target) && Designable.Shared.isPlainObj(source)) {
            Designable.Shared.each(source, function (value, key) {
                var token = lowerSnake(key);
                var messages = mergeLocales(target[key] || target[token], value);
                target[token] = messages;
            });
            return target;
        }
        else if (Designable.Shared.isPlainObj(source)) {
            var result_1 = Array.isArray(source) ? [] : {};
            Designable.Shared.each(source, function (value, key) {
                var messages = mergeLocales(undefined, value);
                result_1[lowerSnake(key)] = messages;
            });
            return result_1;
        }
        return source;
    };
    var getBrowserLanguage = function () {
        var _a;
        /* istanbul ignore next */
        if (!Designable.Shared.globalThisPolyfill.navigator) {
            return 'en';
        }
        return (Designable.Shared.globalThisPolyfill.navigator['browserlanguage'] || ((_a = Designable.Shared.globalThisPolyfill.navigator) === null || _a === void 0 ? void 0 : _a.language) ||
            'en');
    };

    var getISOCode = function (language) {
        var isoCode = DESIGNER_LANGUAGE_STORE.value;
        var lang = lowerSnake(language);
        if (DESIGNER_LOCALES_STORE.value[lang]) {
            return lang;
        }
        Designable.Shared.each(DESIGNER_LOCALES_STORE.value, function (_, key) {
            if (key.indexOf(lang) > -1 || String(lang).indexOf(key) > -1) {
                isoCode = key;
                return false;
            }
        });
        return isoCode;
    };
    var reSortBehaviors = function (target, sources) {
        var findTargetBehavior = function (behavior) { return target.includes(behavior); };
        var findSourceBehavior = function (name) {
            for (var key in sources) {
                var Behavior = sources[key].Behavior;
                for (var i = 0; i < Behavior.length; i++) {
                    if (Behavior[i].name === name)
                        return Behavior[i];
                }
            }
        };
        Designable.Shared.each(sources, function (item) {
            if (!item)
                return;
            if (!isBehaviorHost(item))
                return;
            var Behavior = item.Behavior;
            Designable.Shared.each(Behavior, function (behavior) {
                if (findTargetBehavior(behavior))
                    return;
                var name = behavior.name;
                Designable.Shared.each(behavior.extends, function (dep) {
                    var behavior = findSourceBehavior(dep);
                    if (!behavior)
                        throw new Error("No " + dep + " behavior that " + name + " depends on");
                    if (!findTargetBehavior(behavior)) {
                        target.unshift(behavior);
                    }
                });
                target.push(behavior);
            });
        });
    };
    var DESIGNER_BEHAVIORS_STORE = Formily.Reactive.observable.ref([]);
    var DESIGNER_ICONS_STORE = Formily.Reactive.observable.ref({});
    var DESIGNER_LOCALES_STORE = Formily.Reactive.observable.ref({});
    var DESIGNER_LANGUAGE_STORE = Formily.Reactive.observable.ref(getBrowserLanguage());
    var DESIGNER_GlobalRegistry = {
        setDesignerLanguage: function (lang) {
            DESIGNER_LANGUAGE_STORE.value = lang;
        },
        setDesignerBehaviors: function (behaviors) {
            DESIGNER_BEHAVIORS_STORE.value = behaviors.reduce(function (buf, behavior) {
                if (isBehaviorHost(behavior)) {
                    return buf.concat(behavior.Behavior);
                }
                else if (isBehaviorList(behavior)) {
                    return buf.concat(behavior);
                }
                return buf;
            }, []);
        },
        getDesignerBehaviors: function (node) {
            return DESIGNER_BEHAVIORS_STORE.value.filter(function (pattern) {
                return pattern.selector(node);
            });
        },
        getDesignerIcon: function (name) {
            return DESIGNER_ICONS_STORE[name];
        },
        getDesignerLanguage: function () {
            return getISOCode(DESIGNER_LANGUAGE_STORE.value);
        },
        getDesignerMessage: function (token, locales) {
            var lang = getISOCode(DESIGNER_LANGUAGE_STORE.value);
            var locale = locales ? locales[lang] : DESIGNER_LOCALES_STORE.value[lang];
            if (!locale) {
                for (var key in DESIGNER_LOCALES_STORE.value) {
                    var message = Formily.Path.Path.getIn(DESIGNER_LOCALES_STORE.value[key], lowerSnake(token));
                    if (message)
                        return message;
                }
                return;
            }
            return Formily.Path.Path.getIn(locale, lowerSnake(token));
        },
        registerDesignerIcons: function (map) {
            Object.assign(DESIGNER_ICONS_STORE, map);
        },
        registerDesignerLocales: function () {
            var packages = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                packages[_i] = arguments[_i];
            }
            packages.forEach(function (locales) {
                mergeLocales(DESIGNER_LOCALES_STORE.value, locales);
            });
        },
        registerDesignerBehaviors: function () {
            var packages = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                packages[_i] = arguments[_i];
            }
            var results = [];
            packages.forEach(function (sources) {
                reSortBehaviors(results, sources);
            });
            if (results.length) {
                DESIGNER_BEHAVIORS_STORE.value = results;
            }
        },
    };
    var GlobalRegistry = DESIGNER_GlobalRegistry;

    var TreeNodes = new Map();
    var CommonDesignerPropsMap = new Map();
    var removeNode = function (node) {
        if (node.parent) {
            node.parent.children = node.parent.children.filter(function (child) { return child !== node; });
        }
    };
    var resetNodesParent = function (nodes, parent) {
        var resetDepth = function (node) {
            node.depth = node.parent ? node.parent.depth + 1 : 0;
            node.children.forEach(resetDepth);
        };
        var shallowReset = function (node) {
            node.parent = parent;
            node.root = parent.root;
            resetDepth(node);
        };
        var deepReset = function (node) {
            shallowReset(node);
            resetNodesParent(node.children, node);
        };
        return nodes.map(function (node) {
            if (node === parent)
                return node;
            if (!parent.isSourceNode) {
                if (node.isSourceNode) {
                    node = node.clone(parent);
                    resetDepth(node);
                }
                else if (!node.isRoot && node.isInOperation) {
                    node.root.operation.selection.remove(node);
                    removeNode(node);
                    shallowReset(node);
                }
                else {
                    deepReset(node);
                }
            }
            else {
                deepReset(node);
            }
            if (!TreeNodes.has(node.id)) {
                TreeNodes.set(node.id, node);
                CommonDesignerPropsMap.set(node.componentName, node.designerProps);
            }
            return node;
        });
    };
    var resetParent = function (node, parent) {
        return resetNodesParent([node], parent)[0];
    };
    var resolveDesignerProps = function (node, props) {
        if (Designable.Shared.isFn(props))
            return props(node);
        return props;
    };
    var TreeNode = /** @class */ (function () {
        function TreeNode(node, parent) {
            this.depth = 0;
            this.hidden = false;
            this.componentName = 'NO_NAME_COMPONENT';
            this.sourceName = '';
            this.props = {};
            this.children = [];
            if (node instanceof TreeNode) {
                return node;
            }
            this.id = node.id || Designable.Shared.uid();
            if (parent) {
                this.parent = parent;
                this.depth = parent.depth + 1;
                this.root = parent.root;
                TreeNodes.set(this.id, this);
            }
            else {
                this.root = this;
                this.operation = node.operation;
                this.isSelfSourceNode = node.isSourceNode || false;
                TreeNodes.set(this.id, this);
            }
            if (node) {
                this.from(node);
            }
            this.makeObservable();
        }
        TreeNode.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                componentName: Formily.Reactive.observable.ref,
                props: Formily.Reactive.observable,
                hidden: Formily.Reactive.observable.ref,
                children: Formily.Reactive.observable.shallow,
                designerProps: Formily.Reactive.observable.computed,
                designerLocales: Formily.Reactive.observable.computed,
                wrap: Formily.Reactive.action,
                prepend: Formily.Reactive.action,
                append: Formily.Reactive.action,
                insertAfter: Formily.Reactive.action,
                insertBefore: Formily.Reactive.action,
                remove: Formily.Reactive.action,
                setProps: Formily.Reactive.action,
                setChildren: Formily.Reactive.action,
                setComponentName: Formily.Reactive.action,
            });
        };
        Object.defineProperty(TreeNode.prototype, "designerProps", {
            get: function () {
                var _this = this;
                var behaviors = GlobalRegistry.getDesignerBehaviors(this);
                var designerProps = behaviors.reduce(function (buf, pattern) {
                    if (!pattern.designerProps)
                        return buf;
                    Object.assign(buf, resolveDesignerProps(_this, pattern.designerProps));
                    return buf;
                }, {});
                return designerProps;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "designerLocales", {
            get: function () {
                var behaviors = GlobalRegistry.getDesignerBehaviors(this);
                var designerLocales = behaviors.reduce(function (buf, pattern) {
                    if (!pattern.designerLocales)
                        return buf;
                    mergeLocales(buf, pattern.designerLocales);
                    return buf;
                }, {});
                return designerLocales;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "previous", {
            get: function () {
                if (this.parent === this || !this.parent)
                    return;
                return this.parent.children[this.index - 1];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "next", {
            get: function () {
                if (this.parent === this || !this.parent)
                    return;
                return this.parent.children[this.index + 1];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "siblings", {
            get: function () {
                var _this = this;
                if (this.parent) {
                    return this.parent.children.filter(function (node) { return node !== _this; });
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "index", {
            get: function () {
                if (this.parent === this || !this.parent)
                    return 0;
                return this.parent.children.indexOf(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "descendants", {
            get: function () {
                return this.children.reduce(function (buf, node) {
                    return buf.concat(node).concat(node.descendants);
                }, []);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "isRoot", {
            get: function () {
                return this === this.root;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "isInOperation", {
            get: function () {
                var _a;
                return !!((_a = this.root) === null || _a === void 0 ? void 0 : _a.operation);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "lastChild", {
            get: function () {
                return this.children[this.children.length - 1];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "firstChild", {
            get: function () {
                return this.children[0];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TreeNode.prototype, "isSourceNode", {
            get: function () {
                return this.root.isSelfSourceNode;
            },
            enumerable: false,
            configurable: true
        });
        TreeNode.prototype.getPrevious = function (step) {
            if (step === void 0) { step = 1; }
            return this.parent.children[this.index - step];
        };
        TreeNode.prototype.getAfter = function (step) {
            if (step === void 0) { step = 1; }
            return this.parent.children[this.index + step];
        };
        TreeNode.prototype.getSibling = function (index) {
            if (index === void 0) { index = 0; }
            return this.parent.children[index];
        };
        TreeNode.prototype.getParents = function (node) {
            var _node = node || this;
            return (_node === null || _node === void 0 ? void 0 : _node.parent) ? [_node.parent].concat(this.getParents(_node.parent))
                : [];
        };
        TreeNode.prototype.getParentByDepth = function (depth) {
            if (depth === void 0) { depth = 0; }
            var parent = this.parent;
            if ((parent === null || parent === void 0 ? void 0 : parent.depth) === depth) {
                return parent;
            }
            else {
                return parent === null || parent === void 0 ? void 0 : parent.getParentByDepth(depth);
            }
        };
        TreeNode.prototype.getMessage = function (token) {
            return GlobalRegistry.getDesignerMessage(token, this.designerLocales);
        };
        TreeNode.prototype.isMyAncestor = function (node) {
            if (node === this || this.parent === node)
                return false;
            return node.contains(this);
        };
        TreeNode.prototype.isMyParent = function (node) {
            return this.parent === node;
        };
        TreeNode.prototype.isMyParents = function (node) {
            if (node === this)
                return false;
            return this.isMyParent(node) || this.isMyAncestor(node);
        };
        TreeNode.prototype.isMyChild = function (node) {
            return node.isMyParent(this);
        };
        TreeNode.prototype.isMyChildren = function (node) {
            return node.isMyParents(this);
        };
        TreeNode.prototype.takeSnapshot = function (type) {
            var _a;
            if ((_a = this.root) === null || _a === void 0 ? void 0 : _a.operation) {
                this.root.operation.snapshot(type);
            }
        };
        TreeNode.prototype.triggerMutation = function (event, callback, defaults) {
            var _a;
            if ((_a = this.root) === null || _a === void 0 ? void 0 : _a.operation) {
                var result = this.root.operation.dispatch(event, callback) || defaults;
                this.takeSnapshot(event === null || event === void 0 ? void 0 : event.type);
                return result;
            }
            else if (Designable.Shared.isFn(callback)) {
                return callback();
            }
        };
        TreeNode.prototype.find = function (finder) {
            if (finder(this)) {
                return this;
            }
            else {
                var finded_1 = undefined;
                this.eachChildren(function (node) {
                    if (finder(node)) {
                        finded_1 = node;
                        return false;
                    }
                });
                return finded_1;
            }
        };
        TreeNode.prototype.findAll = function (finder) {
            var results = [];
            if (finder(this)) {
                results.push(this);
            }
            this.eachChildren(function (node) {
                if (finder(node)) {
                    results.push(node);
                }
            });
            return results;
        };
        TreeNode.prototype.distanceTo = function (node) {
            if (this.root !== node.root) {
                return Infinity;
            }
            if (this.parent !== node.parent) {
                return Infinity;
            }
            return Math.abs(this.index - node.index);
        };
        TreeNode.prototype.crossSiblings = function (node) {
            if (this.parent !== node.parent)
                return [];
            var minIndex = Math.min(this.index, node.index);
            var maxIndex = Math.max(this.index, node.index);
            var results = [];
            for (var i = minIndex + 1; i < maxIndex; i++) {
                results.push(this.parent.children[i]);
            }
            return results;
        };
        TreeNode.prototype.allowSibling = function (nodes) {
            var _a, _b, _c;
            if (((_b = (_a = this.designerProps) === null || _a === void 0 ? void 0 : _a.allowSiblings) === null || _b === void 0 ? void 0 : _b.call(_a, this, nodes)) === false)
                return false;
            return (_c = this.parent) === null || _c === void 0 ? void 0 : _c.allowAppend(nodes);
        };
        TreeNode.prototype.allowDrop = function (parent) {
            if (!Designable.Shared.isFn(this.designerProps.allowDrop))
                return true;
            return this.designerProps.allowDrop(parent);
        };
        TreeNode.prototype.allowAppend = function (nodes) {
            var _this = this;
            var _a, _b, _c;
            if (!((_a = this.designerProps) === null || _a === void 0 ? void 0 : _a.droppable))
                return false;
            if (((_c = (_b = this.designerProps) === null || _b === void 0 ? void 0 : _b.allowAppend) === null || _c === void 0 ? void 0 : _c.call(_b, this, nodes)) === false)
                return false;
            if (nodes.some(function (node) { return !node.allowDrop(_this); }))
                return false;
            if (this.root === this)
                return true;
            return true;
        };
        TreeNode.prototype.allowClone = function () {
            var _a;
            if (this === this.root)
                return false;
            return (_a = this.designerProps.cloneable) !== null && _a !== void 0 ? _a : true;
        };
        TreeNode.prototype.allowDrag = function () {
            var _a;
            if (this === this.root && !this.isSourceNode)
                return false;
            return (_a = this.designerProps.draggable) !== null && _a !== void 0 ? _a : true;
        };
        TreeNode.prototype.allowResize = function () {
            if (this === this.root && !this.isSourceNode)
                return false;
            var resizable = this.designerProps.resizable;
            if (!resizable)
                return false;
            if (resizable.width && resizable.height)
                return ['x', 'y'];
            if (resizable.width)
                return ['x'];
            return ['y'];
        };
        TreeNode.prototype.allowTranslate = function () {
            if (this === this.root && !this.isSourceNode)
                return false;
            var translatable = this.designerProps.translatable;
            if ((translatable === null || translatable === void 0 ? void 0 : translatable.x) && (translatable === null || translatable === void 0 ? void 0 : translatable.y))
                return true;
            return false;
        };
        TreeNode.prototype.allowDelete = function () {
            var _a;
            if (this === this.root)
                return false;
            return (_a = this.designerProps.deletable) !== null && _a !== void 0 ? _a : true;
        };
        TreeNode.prototype.findById = function (id) {
            var _a;
            if (!id)
                return;
            if (this.id === id)
                return this;
            if (((_a = this.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return TreeNodes.get(id);
            }
        };
        TreeNode.prototype.contains = function () {
            var _this = this;
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            return nodes.every(function (node) {
                if (node === _this ||
                    (node === null || node === void 0 ? void 0 : node.parent) === _this ||
                    (node === null || node === void 0 ? void 0 : node.getParentByDepth(_this.depth)) === _this) {
                    return true;
                }
                return false;
            });
        };
        TreeNode.prototype.eachChildren = function (callback) {
            if (Designable.Shared.isFn(callback)) {
                for (var i = 0; i < this.children.length; i++) {
                    var node = this.children[i];
                    if (callback(node) === false)
                        return;
                    node.eachChildren(callback);
                }
            }
        };
        TreeNode.prototype.resetNodesParent = function (nodes, parent) {
            var _this = this;
            return resetNodesParent(nodes.filter(function (node) { return node !== _this; }), parent);
        };
        TreeNode.prototype.setProps = function (props) {
            var _this = this;
            return this.triggerMutation(new UpdateNodePropsEvent({
                target: this,
                source: null,
            }), function () {
                Object.assign(_this.props, props);
            });
        };
        TreeNode.prototype.setComponentName = function (componentName) {
            this.componentName = componentName;
        };
        TreeNode.prototype.prepend = function () {
            var _this = this;
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            if (nodes.some(function (node) { return node.contains(_this); }))
                return [];
            var originSourceParents = nodes.map(function (node) { return node.parent; });
            var newNodes = this.resetNodesParent(nodes, this);
            if (!newNodes.length)
                return [];
            return this.triggerMutation(new PrependNodeEvent({
                originSourceParents: originSourceParents,
                target: this,
                source: newNodes,
            }), function () {
                _this.children = newNodes.concat(_this.children);
                return newNodes;
            }, []);
        };
        TreeNode.prototype.append = function () {
            var _this = this;
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            if (nodes.some(function (node) { return node.contains(_this); }))
                return [];
            var originSourceParents = nodes.map(function (node) { return node.parent; });
            var newNodes = this.resetNodesParent(nodes, this);
            if (!newNodes.length)
                return [];
            return this.triggerMutation(new AppendNodeEvent({
                originSourceParents: originSourceParents,
                target: this,
                source: newNodes,
            }), function () {
                _this.children = _this.children.concat(newNodes);
                return newNodes;
            }, []);
        };
        TreeNode.prototype.wrap = function (wrapper) {
            var _this = this;
            if (wrapper === this)
                return;
            var parent = this.parent;
            return this.triggerMutation(new WrapNodeEvent({
                target: this,
                source: wrapper,
            }), function () {
                resetParent(_this, wrapper);
                resetParent(wrapper, parent);
                return wrapper;
            });
        };
        TreeNode.prototype.insertAfter = function () {
            var _this = this;
            var _a;
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            var parent = this.parent;
            if (nodes.some(function (node) { return node.contains(_this); }))
                return [];
            if ((_a = parent === null || parent === void 0 ? void 0 : parent.children) === null || _a === void 0 ? void 0 : _a.length) {
                var originSourceParents = nodes.map(function (node) { return node.parent; });
                var newNodes_1 = this.resetNodesParent(nodes, parent);
                if (!newNodes_1.length)
                    return [];
                return this.triggerMutation(new InsertAfterEvent({
                    originSourceParents: originSourceParents,
                    target: this,
                    source: newNodes_1,
                }), function () {
                    parent.children = parent.children.reduce(function (buf, node) {
                        if (node === _this) {
                            return buf.concat([node]).concat(newNodes_1);
                        }
                        else {
                            return buf.concat([node]);
                        }
                    }, []);
                    return newNodes_1;
                }, []);
            }
            return [];
        };
        TreeNode.prototype.insertBefore = function () {
            var _this = this;
            var _a;
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            var parent = this.parent;
            if (nodes.some(function (node) { return node.contains(_this); }))
                return [];
            if ((_a = parent === null || parent === void 0 ? void 0 : parent.children) === null || _a === void 0 ? void 0 : _a.length) {
                var originSourceParents = nodes.map(function (node) { return node.parent; });
                var newNodes_2 = this.resetNodesParent(nodes, parent);
                if (!newNodes_2.length)
                    return [];
                return this.triggerMutation(new InsertBeforeEvent({
                    originSourceParents: originSourceParents,
                    target: this,
                    source: newNodes_2,
                }), function () {
                    parent.children = parent.children.reduce(function (buf, node) {
                        if (node === _this) {
                            return buf.concat(newNodes_2).concat([node]);
                        }
                        else {
                            return buf.concat([node]);
                        }
                    }, []);
                    return newNodes_2;
                }, []);
            }
            return [];
        };
        TreeNode.prototype.insertChildren = function (start) {
            var _this = this;
            var _a;
            var nodes = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                nodes[_i - 1] = arguments[_i];
            }
            if (nodes.some(function (node) { return node.contains(_this); }))
                return [];
            if ((_a = this.children) === null || _a === void 0 ? void 0 : _a.length) {
                var originSourceParents = nodes.map(function (node) { return node.parent; });
                var newNodes_3 = this.resetNodesParent(nodes, this);
                if (!newNodes_3.length)
                    return [];
                return this.triggerMutation(new InsertChildrenEvent({
                    originSourceParents: originSourceParents,
                    target: this,
                    source: newNodes_3,
                }), function () {
                    _this.children = _this.children.reduce(function (buf, node, index) {
                        if (index === start) {
                            return buf.concat(newNodes_3).concat([node]);
                        }
                        return buf.concat([node]);
                    }, []);
                    return newNodes_3;
                }, []);
            }
            return [];
        };
        TreeNode.prototype.setChildren = function () {
            var _this = this;
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            var originSourceParents = nodes.map(function (node) { return node.parent; });
            var newNodes = this.resetNodesParent(nodes, this);
            return this.triggerMutation(new UpdateChildrenEvent({
                originSourceParents: originSourceParents,
                target: this,
                source: newNodes,
            }), function () {
                _this.children = newNodes;
                return newNodes;
            }, []);
        };
        /**
         * @deprecated
         * please use `setChildren`
         */
        TreeNode.prototype.setNodeChildren = function () {
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            return this.setChildren.apply(this, __spread(nodes));
        };
        TreeNode.prototype.remove = function () {
            var _this = this;
            return this.triggerMutation(new RemoveNodeEvent({
                target: this,
                source: null,
            }), function () {
                removeNode(_this);
                TreeNodes.delete(_this.id);
            });
        };
        TreeNode.prototype.clone = function (parent) {
            var newNode = new TreeNode({
                id: Designable.Shared.uid(),
                componentName: this.componentName,
                sourceName: this.sourceName,
                props: Formily.Reactive.toJS(this.props),
                children: [],
            }, parent ? parent : this.parent);
            newNode.children = resetNodesParent(this.children.map(function (child) {
                return child.clone(newNode);
            }), newNode);
            return this.triggerMutation(new CloneNodeEvent({
                target: this,
                source: newNode,
            }), function () { return newNode; });
        };
        TreeNode.prototype.from = function (node) {
            var _this = this;
            if (!node)
                return;
            return this.triggerMutation(new FromNodeEvent({
                target: this,
                source: node,
            }), function () {
                var _a, _b, _c;
                if (node.id && node.id !== _this.id) {
                    TreeNodes.delete(_this.id);
                    TreeNodes.set(node.id, _this);
                    _this.id = node.id;
                }
                if (node.componentName) {
                    _this.componentName = node.componentName;
                }
                _this.props = (_a = node.props) !== null && _a !== void 0 ? _a : {};
                if (node.hidden) {
                    _this.hidden = node.hidden;
                }
                if (node.children) {
                    _this.children =
                        ((_c = (_b = node.children) === null || _b === void 0 ? void 0 : _b.map) === null || _c === void 0 ? void 0 : _c.call(_b, function (node) {
                            return new TreeNode(node, _this);
                        })) || [];
                }
            });
        };
        TreeNode.prototype.serialize = function () {
            return {
                id: this.id,
                componentName: this.componentName,
                sourceName: this.sourceName,
                props: Formily.Reactive.toJS(this.props),
                hidden: this.hidden,
                children: this.children.map(function (treeNode) {
                    return treeNode.serialize();
                }),
            };
        };
        TreeNode.create = function (node, parent) {
            return new TreeNode(node, parent);
        };
        TreeNode.findById = function (id) {
            return TreeNodes.get(id);
        };
        return TreeNode;
    }());

    var toArray = function (target) {
        return Array.from(target || []);
    };
    var Selector = /** @class */ (function () {
        function Selector() {
            this.store = new Map();
        }
        Selector.prototype._queryAll = function (target, selector) {
            if (!target)
                return [];
            var results = toArray(target === null || target === void 0 ? void 0 : target.querySelectorAll(selector));
            var cacheKey = selector + '@ALL';
            var caches = this.store.get(cacheKey);
            if (caches) {
                caches.set(target, results);
            }
            else {
                this.store.set(cacheKey, new WeakMap([[target, results]]));
            }
            return results;
        };
        Selector.prototype._query = function (target, selector) {
            if (!target)
                return;
            var results = target === null || target === void 0 ? void 0 : target.querySelector(selector);
            var caches = this.store.get(selector);
            if (caches) {
                caches.set(target, results);
            }
            else {
                this.store.set(selector, new WeakMap([[target, results]]));
            }
            return results;
        };
        Selector.prototype._clean = function (target, key) {
            var caches = this.store.get(key);
            if (caches) {
                caches.delete(target);
            }
        };
        Selector.prototype.queryAll = function (target, selector) {
            var cacheKey = selector + '@ALL';
            var caches = this.store.get(cacheKey);
            var results = { current: null };
            if (caches) {
                results.current = caches.get(target);
                if (Array.isArray(results.current)) {
                    if (results.current.length === 0 ||
                        results.current.some(function (node) { return !node.isConnected; })) {
                        this._clean(target, cacheKey);
                        return this._queryAll(target, selector);
                    }
                    return results.current;
                }
                this._clean(target, cacheKey);
                return this._queryAll(target, selector);
            }
            else {
                return this._queryAll(target, selector);
            }
        };
        Selector.prototype.query = function (target, selector) {
            var caches = this.store.get(selector);
            var results = { current: null };
            if (caches) {
                results.current = caches.get(target);
                if (results.current && !Array.isArray(results.current)) {
                    if (!results.current.isConnected) {
                        this._clean(target, selector);
                        return this._query(target, selector);
                    }
                    return results.current;
                }
                this._clean(target, selector);
                return this._query(target, selector);
            }
            else {
                return this._query(target, selector);
            }
        };
        return Selector;
    }());

    /**
     * 
     */
    var Viewport = /** @class */ (function () {
        function Viewport(props) {
            this.scrollX = 0;
            this.scrollY = 0;
            this.width = 0;
            this.height = 0;
            this.workspace = props.workspace;
            this.engine = props.engine;
            this.viewportElement = props.viewportElement;
            this.contentWindow = props.contentWindow;
            this.nodeIdAttrName = props.nodeIdAttrName;
            this.selector = new Selector();
            this.digestViewport();
            this.makeObservable();
            this.attachEvents();
        }
        Object.defineProperty(Viewport.prototype, "isScrollLeft", {
            get: function () {
                return this.scrollX === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "isScrollTop", {
            get: function () {
                return this.scrollY === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "isScrollRight", {
            get: function () {
                var _a, _b, _c, _d;
                if (this.isIframe) {
                    return (this.width + this.scrollX >= ((_c = (_b = (_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.document) === null || _b === void 0 ? void 0 : _b.body) === null || _c === void 0 ? void 0 : _c.scrollWidth));
                }
                else if (this.viewportElement) {
                    return this.width + this.scrollX >= ((_d = this.viewportElement) === null || _d === void 0 ? void 0 : _d.scrollWidth);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "isScrollBottom", {
            get: function () {
                var _a, _b, _c, _d;
                if (this.isIframe) {
                    return (this.height + this.scrollY >= ((_c = (_b = (_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.document) === null || _b === void 0 ? void 0 : _b.body) === null || _c === void 0 ? void 0 : _c.scrollHeight));
                }
                else if (this.viewportElement) {
                    return this.height + this.scrollY >= ((_d = this.viewportElement) === null || _d === void 0 ? void 0 : _d.scrollHeight);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "viewportRoot", {
            get: function () {
                var _a, _b;
                return this.isIframe
                    ? (_b = (_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.document) === null || _b === void 0 ? void 0 : _b.body : this.viewportElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "isMaster", {
            get: function () {
                return this.contentWindow === Designable.Shared.globalThisPolyfill;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "isIframe", {
            get: function () {
                var _a;
                return !!((_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.frameElement) && !this.isMaster;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "scrollContainer", {
            get: function () {
                return this.isIframe ? this.contentWindow : this.viewportElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "rect", {
            get: function () {
                var viewportElement = this.viewportElement;
                if (viewportElement)
                    return this.getElementRect(viewportElement);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "innerRect", {
            get: function () {
                var rect = this.rect;
                return (typeof DOMRect !== 'undefined' &&
                    new DOMRect(0, 0, rect === null || rect === void 0 ? void 0 : rect.width, rect === null || rect === void 0 ? void 0 : rect.height));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "offsetX", {
            get: function () {
                var rect = this.rect;
                if (!rect)
                    return 0;
                return rect.x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "offsetY", {
            get: function () {
                var rect = this.rect;
                if (!rect)
                    return 0;
                return rect.y;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Viewport.prototype, "scale", {
            get: function () {
                if (!this.viewportElement)
                    return 1;
                var clientRect = this.viewportElement.getBoundingClientRect();
                var offsetWidth = this.viewportElement.offsetWidth;
                return Math.round(clientRect.width / offsetWidth);
            },
            enumerable: false,
            configurable: true
        });
        Viewport.prototype.digestViewport = function () {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (this.isIframe) {
                this.scrollX = ((_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.scrollX) || 0;
                this.scrollY = ((_b = this.contentWindow) === null || _b === void 0 ? void 0 : _b.scrollY) || 0;
                this.width = ((_c = this.contentWindow) === null || _c === void 0 ? void 0 : _c.innerWidth) || 0;
                this.height = ((_d = this.contentWindow) === null || _d === void 0 ? void 0 : _d.innerHeight) || 0;
            }
            else if (this.viewportElement) {
                this.scrollX = ((_e = this.viewportElement) === null || _e === void 0 ? void 0 : _e.scrollLeft) || 0;
                this.scrollY = ((_f = this.viewportElement) === null || _f === void 0 ? void 0 : _f.scrollTop) || 0;
                this.width = ((_g = this.viewportElement) === null || _g === void 0 ? void 0 : _g.clientWidth) || 0;
                this.height = ((_h = this.viewportElement) === null || _h === void 0 ? void 0 : _h.clientHeight) || 0;
            }
        };
        Viewport.prototype.elementFromPoint = function (point) {
            var _a;
            if ((_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.document) {
                return this.contentWindow.document.elementFromPoint(point.x, point.y);
            }
        };
        Viewport.prototype.matchViewport = function (target) {
            var _a;
            if (this.isIframe) {
                return (target === this.viewportElement ||
                    target === this.contentWindow ||
                    target === ((_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.document));
            }
            else {
                return target === this.viewportElement;
            }
        };
        Viewport.prototype.attachEvents = function () {
            var _this = this;
            var engine = this.engine;
            Designable.Shared.cancelIdle(this.attachRequest);
            this.attachRequest = Designable.Shared.requestIdle(function () {
                if (!engine)
                    return;
                if (_this.isIframe) {
                    _this.workspace.attachEvents(_this.contentWindow, _this.contentWindow);
                }
                else if (Designable.Shared.isHTMLElement(_this.viewportElement)) {
                    _this.workspace.attachEvents(_this.viewportElement, _this.contentWindow);
                }
            });
        };
        Viewport.prototype.detachEvents = function () {
            if (this.isIframe) {
                this.workspace.detachEvents(this.contentWindow);
                this.workspace.detachEvents(this.viewportElement);
            }
            else if (this.viewportElement) {
                this.workspace.detachEvents(this.viewportElement);
            }
        };
        Viewport.prototype.onMount = function (element, contentWindow) {
            this.viewportElement = element;
            this.contentWindow = contentWindow;
            this.attachEvents();
            this.digestViewport();
        };
        Viewport.prototype.onUnmount = function () {
            this.detachEvents();
        };
        Viewport.prototype.isPointInViewport = function (point, sensitive) {
            if (!this.rect)
                return false;
            if (!this.containsElement(document.elementFromPoint(point.x, point.y)))
                return false;
            return Designable.Shared.isPointInRect(point, this.rect, sensitive);
        };
        Viewport.prototype.isPointInViewportArea = function (point, sensitive) {
            if (!this.rect)
                return false;
            return Designable.Shared.isPointInRect(point, this.rect, sensitive);
        };
        Viewport.prototype.isOffsetPointInViewport = function (point, sensitive) {
            if (!this.innerRect)
                return false;
            if (!this.containsElement(document.elementFromPoint(point.x, point.y)))
                return false;
            return Designable.Shared.isPointInRect(point, this.innerRect, sensitive);
        };
        Viewport.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                scrollX: Formily.Reactive.observable.ref,
                scrollY: Formily.Reactive.observable.ref,
                width: Formily.Reactive.observable.ref,
                height: Formily.Reactive.observable.ref,
                digestViewport: Formily.Reactive.action,
                viewportElement: Formily.Reactive.observable.ref,
                contentWindow: Formily.Reactive.observable.ref,
            });
        };
        Viewport.prototype.findElementById = function (id) {
            return this.selector.query(this.viewportRoot, "*[" + this.nodeIdAttrName + "='" + id + "']\n      ");
        };
        Viewport.prototype.findElementsById = function (id) {
            if (!id)
                return [];
            return this.selector.queryAll(this.viewportRoot, "*[" + this.nodeIdAttrName + "='" + id + "']\n      ");
        };
        Viewport.prototype.containsElement = function (element) {
            var root = this.viewportElement;
            if (root === element)
                return true;
            return root === null || root === void 0 ? void 0 : root.contains(element);
        };
        Viewport.prototype.getOffsetPoint = function (topPoint) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (this.isIframe) {
                return {
                    x: topPoint.x - this.offsetX + ((_b = (_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.scrollX) !== null && _b !== void 0 ? _b : 0),
                    y: topPoint.y - this.offsetY + ((_d = (_c = this.contentWindow) === null || _c === void 0 ? void 0 : _c.scrollY) !== null && _d !== void 0 ? _d : 0),
                };
            }
            else {
                return {
                    x: topPoint.x - this.offsetX + ((_f = (_e = this.viewportElement) === null || _e === void 0 ? void 0 : _e.scrollLeft) !== null && _f !== void 0 ? _f : 0),
                    y: topPoint.y - this.offsetY + ((_h = (_g = this.viewportElement) === null || _g === void 0 ? void 0 : _g.scrollTop) !== null && _h !== void 0 ? _h : 0),
                };
            }
        };
        Viewport.prototype.getElementRect = function (element) {
            var rect = element.getBoundingClientRect();
            var offsetWidth = element['offsetWidth']
                ? element['offsetWidth']
                : rect.width;
            var offsetHeight = element['offsetHeight']
                ? element['offsetHeight']
                : rect.height;
            return (typeof DOMRect !== 'undefined' &&
                new DOMRect(rect.x, rect.y, this.scale !== 1 ? offsetWidth : rect.width, this.scale !== 1 ? offsetHeight : rect.height));
        };
        /**
         * 
         * @param id
         */
        Viewport.prototype.getElementRectById = function (id) {
            var _this = this;
            var elements = this.findElementsById(id);
            var rect = Designable.Shared.calcBoundingRect(elements.map(function (element) { return _this.getElementRect(element); }));
            if (rect) {
                if (this.isIframe) {
                    return (typeof DOMRect !== 'undefined' &&
                        new DOMRect(rect.x + this.offsetX, rect.y + this.offsetY, rect.width, rect.height));
                }
                else {
                    return (typeof DOMRect !== 'undefined' &&
                        new DOMRect(rect.x, rect.y, rect.width, rect.height));
                }
            }
        };
        /**
         * 
         * @param id
         */
        Viewport.prototype.getElementOffsetRectById = function (id) {
            var _this = this;
            var elements = this.findElementsById(id);
            if (!elements.length)
                return;
            var elementRect = Designable.Shared.calcBoundingRect(elements.map(function (element) { return _this.getElementRect(element); }));
            if (elementRect) {
                if (this.isIframe) {
                    return (typeof DOMRect !== 'undefined' &&
                        new DOMRect(elementRect.x + this.contentWindow.scrollX, elementRect.y + this.contentWindow.scrollY, elementRect.width, elementRect.height));
                }
                else {
                    return (typeof DOMRect !== 'undefined' &&
                        new DOMRect((elementRect.x - this.offsetX + this.viewportElement.scrollLeft) /
                            this.scale, (elementRect.y - this.offsetY + this.viewportElement.scrollTop) /
                            this.scale, elementRect.width, elementRect.height));
                }
            }
        };
        Viewport.prototype.getValidNodeElement = function (node) {
            var _this = this;
            var getNodeElement = function (node) {
                if (!node)
                    return;
                var ele = _this.findElementById(node.id);
                if (ele) {
                    return ele;
                }
                else {
                    return getNodeElement(node.parent);
                }
            };
            return getNodeElement(node);
        };
        Viewport.prototype.getChildrenRect = function (node) {
            var _this = this;
            var _a;
            if (!((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length))
                return;
            return Designable.Shared.calcBoundingRect(node.children.reduce(function (buf, child) {
                var rect = _this.getValidNodeRect(child);
                if (rect) {
                    return buf.concat(rect);
                }
                return buf;
            }, []));
        };
        Viewport.prototype.getChildrenOffsetRect = function (node) {
            var _this = this;
            var _a;
            if (!((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length))
                return;
            return Designable.Shared.calcBoundingRect(node.children.reduce(function (buf, child) {
                var rect = _this.getValidNodeOffsetRect(child);
                if (rect) {
                    return buf.concat(rect);
                }
                return buf;
            }, []));
        };
        Viewport.prototype.getValidNodeRect = function (node) {
            if (!node)
                return;
            var rect = this.getElementRectById(node.id);
            if (node && node === node.root) {
                if (!rect)
                    return this.rect;
                return Designable.Shared.calcBoundingRect([this.rect, rect]);
            }
            if (rect) {
                return rect;
            }
            else {
                return this.getChildrenRect(node);
            }
        };
        Viewport.prototype.getValidNodeOffsetRect = function (node) {
            if (!node)
                return;
            var rect = this.getElementOffsetRectById(node.id);
            if (node && node === node.root) {
                if (!rect)
                    return this.innerRect;
                return Designable.Shared.calcBoundingRect([this.innerRect, rect]);
            }
            if (rect) {
                return rect;
            }
            else {
                return this.getChildrenOffsetRect(node);
            }
        };
        Viewport.prototype.getValidNodeLayout = function (node) {
            var _a, _b;
            if (!node)
                return 'vertical';
            if ((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.designerProps) === null || _b === void 0 ? void 0 : _b.inlineChildrenLayout)
                return 'horizontal';
            return Designable.Shared.calcElementLayout(this.findElementById(node.id));
        };
        return Viewport;
    }());

    var Selection = /** @class */ (function () {
        function Selection(props) {
            this.selected = [];
            if (props.selected) {
                this.selected = props.selected;
            }
            if (props.operation) {
                this.operation = props.operation;
            }
            this.makeObservable();
        }
        Selection.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                selected: Formily.Reactive.observable,
                select: Formily.Reactive.action,
                batchSelect: Formily.Reactive.action,
                add: Formily.Reactive.action,
                remove: Formily.Reactive.action,
                clear: Formily.Reactive.action,
                crossAddTo: Formily.Reactive.action,
            });
        };
        Selection.prototype.trigger = function (type) {
            if (type === void 0) { type = SelectNodeEvent; }
            return this.operation.dispatch(new type({
                target: this.operation.tree,
                source: this.operation.getSelectedNodes(),
            }));
        };
        Selection.prototype.select = function (id) {
            if (Designable.Shared.isStr(id)) {
                if (this.selected.length === 1 && this.selected.includes(id)) {
                    this.trigger(SelectNodeEvent);
                    return;
                }
                this.selected = [id];
                this.trigger(SelectNodeEvent);
            }
            else {
                this.select(id === null || id === void 0 ? void 0 : id.id);
            }
        };
        Selection.prototype.safeSelect = function (id) {
            if (!id)
                return;
            this.select(id);
        };
        Selection.prototype.mapIds = function (ids) {
            return Designable.Shared.isArr(ids)
                ? ids.map(function (node) { return (Designable.Shared.isStr(node) ? node : node === null || node === void 0 ? void 0 : node.id); })
                : [];
        };
        Selection.prototype.batchSelect = function (ids) {
            this.selected = this.mapIds(ids);
            this.trigger(SelectNodeEvent);
        };
        Selection.prototype.batchSafeSelect = function (ids) {
            if (!(ids === null || ids === void 0 ? void 0 : ids.length))
                return;
            this.batchSelect(ids);
        };
        Object.defineProperty(Selection.prototype, "first", {
            get: function () {
                if (this.selected && this.selected.length)
                    return this.selected[0];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "last", {
            get: function () {
                if (this.selected && this.selected.length)
                    return this.selected[this.selected.length - 1];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "length", {
            get: function () {
                return this.selected.length;
            },
            enumerable: false,
            configurable: true
        });
        Selection.prototype.add = function () {
            var _this = this;
            var ids = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ids[_i] = arguments[_i];
            }
            this.mapIds(ids).forEach(function (id) {
                if (Designable.Shared.isStr(id)) {
                    if (!_this.selected.includes(id)) {
                        _this.selected.push(id);
                    }
                }
                else {
                    _this.add(id === null || id === void 0 ? void 0 : id.id);
                }
            });
            this.trigger();
        };
        Selection.prototype.crossAddTo = function (node) {
            var _this = this;
            if (node.parent) {
                var selectedNodes = this.operation.getSelectedNodes();
                if (this.has(node)) {
                    this.remove(node);
                }
                else {
                    var minDistanceNode = selectedNodes.reduce(function (minDistanceNode, item) {
                        return item.distanceTo(node) < minDistanceNode.distanceTo(node)
                            ? item
                            : minDistanceNode;
                    }, selectedNodes[0]);
                    if (minDistanceNode) {
                        var crossNodes = node.crossSiblings(minDistanceNode);
                        crossNodes.forEach(function (node) {
                            if (!_this.selected.includes(node.id)) {
                                _this.selected.push(node.id);
                            }
                        });
                    }
                    if (!this.selected.includes(node.id)) {
                        this.selected.push(node.id);
                    }
                }
            }
        };
        Selection.prototype.remove = function () {
            var _this = this;
            var ids = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ids[_i] = arguments[_i];
            }
            this.mapIds(ids).forEach(function (id) {
                if (Designable.Shared.isStr(id)) {
                    _this.selected = _this.selected.filter(function (item) { return item !== id; });
                }
                else {
                    _this.remove(id === null || id === void 0 ? void 0 : id.id);
                }
            });
            this.trigger(UnSelectNodeEvent);
        };
        Selection.prototype.has = function () {
            var _this = this;
            var ids = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ids[_i] = arguments[_i];
            }
            return this.mapIds(ids).some(function (id) {
                if (Designable.Shared.isStr(id)) {
                    return _this.selected.includes(id);
                }
                else {
                    if (!(id === null || id === void 0 ? void 0 : id.id))
                        return false;
                    return _this.has(id === null || id === void 0 ? void 0 : id.id);
                }
            });
        };
        Selection.prototype.clear = function () {
            this.selected = [];
            this.trigger(UnSelectNodeEvent);
        };
        return Selection;
    }());

    var Hover = /** @class */ (function () {
        function Hover(props) {
            this.node = null;
            this.operation = props === null || props === void 0 ? void 0 : props.operation;
            this.makeObservable();
        }
        Hover.prototype.setHover = function (node) {
            if (node) {
                this.node = node;
            }
            else {
                this.node = null;
            }
            this.trigger();
        };
        Hover.prototype.clear = function () {
            this.node = null;
        };
        Hover.prototype.trigger = function () {
            if (this.operation) {
                return this.operation.dispatch(new HoverNodeEvent({
                    target: this.operation.tree,
                    source: this.node,
                }));
            }
        };
        Hover.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                node: Formily.Reactive.observable.ref,
                setHover: Formily.Reactive.action,
                clear: Formily.Reactive.action,
            });
        };
        return Hover;
    }());

    exports.ClosestPosition = void 0;
    (function (ClosestPosition) {
        ClosestPosition["Before"] = "BEFORE";
        ClosestPosition["ForbidBefore"] = "FORBID_BEFORE";
        ClosestPosition["After"] = "After";
        ClosestPosition["ForbidAfter"] = "FORBID_AFTER";
        ClosestPosition["Upper"] = "UPPER";
        ClosestPosition["ForbidUpper"] = "FORBID_UPPER";
        ClosestPosition["Under"] = "UNDER";
        ClosestPosition["ForbidUnder"] = "FORBID_UNDER";
        ClosestPosition["Inner"] = "INNER";
        ClosestPosition["ForbidInner"] = "FORBID_INNER";
        ClosestPosition["InnerAfter"] = "INNER_AFTER";
        ClosestPosition["ForbidInnerAfter"] = "FORBID_INNER_AFTER";
        ClosestPosition["InnerBefore"] = "INNER_BEFORE";
        ClosestPosition["ForbidInnerBefore"] = "FORBID_INNER_BEFORE";
        ClosestPosition["Forbid"] = "FORBID";
    })(exports.ClosestPosition || (exports.ClosestPosition = {}));
    var Dragon = /** @class */ (function () {
        function Dragon(props) {
            this.dragNodes = [];
            this.touchNode = null;
            this.dropNode = null;
            this.closestNode = null;
            this.closestRect = null;
            this.closestOffsetRect = null;
            this.closestDirection = null;
            this.sensitive = true;
            this.forceBlock = false;
            this.viewport = null;
            this.operation = props.operation;
            this.viewport = props.viewport;
            this.sensitive = props.sensitive;
            this.forceBlock = props.forceBlock;
            this.rootNode = this.operation.tree;
            this.makeObservable();
        }
        Dragon.prototype.getClosestLayout = function () {
            return this.viewport.getValidNodeLayout(this.closestNode);
        };
        /**
         * 
         * @readonly
         * @type {ClosestPosition}
         * @memberof Dragon
         */
        Dragon.prototype.getClosestPosition = function (point) {
            var _this = this;
            var closestNode = this.closestNode;
            if (!closestNode)
                return exports.ClosestPosition.Forbid;
            var closestRect = this.viewport.getValidNodeRect(closestNode);
            var isInline = this.getClosestLayout() === 'horizontal';
            if (!closestRect) {
                return;
            }
            var isAfter = Designable.Shared.isNearAfter(point, closestRect, this.forceBlock ? false : isInline);
            var getValidParent = function (node) {
                var _a;
                if (!node)
                    return;
                if ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.allowSibling(_this.dragNodes))
                    return node.parent;
                return getValidParent(node.parent);
            };
            if (Designable.Shared.isPointInRect(point, closestRect, this.sensitive)) {
                if (!closestNode.allowAppend(this.dragNodes)) {
                    if (!closestNode.allowSibling(this.dragNodes)) {
                        var parentClosestNode = getValidParent(closestNode);
                        if (parentClosestNode) {
                            this.closestNode = parentClosestNode;
                        }
                        if (isInline) {
                            if (parentClosestNode) {
                                if (isAfter) {
                                    return exports.ClosestPosition.After;
                                }
                                return exports.ClosestPosition.Before;
                            }
                            if (isAfter) {
                                return exports.ClosestPosition.ForbidAfter;
                            }
                            return exports.ClosestPosition.ForbidBefore;
                        }
                        else {
                            if (parentClosestNode) {
                                if (isAfter) {
                                    return exports.ClosestPosition.Under;
                                }
                                return exports.ClosestPosition.Upper;
                            }
                            if (isAfter) {
                                return exports.ClosestPosition.ForbidUnder;
                            }
                            return exports.ClosestPosition.ForbidUpper;
                        }
                    }
                    else {
                        if (isInline) {
                            return isAfter ? exports.ClosestPosition.After : exports.ClosestPosition.Before;
                        }
                        else {
                            return isAfter ? exports.ClosestPosition.Under : exports.ClosestPosition.Upper;
                        }
                    }
                }
                if (closestNode.contains.apply(closestNode, __spread(this.dragNodes))) {
                    if (isAfter) {
                        return exports.ClosestPosition.InnerAfter;
                    }
                    return exports.ClosestPosition.InnerBefore;
                }
                else {
                    return exports.ClosestPosition.Inner;
                }
            }
            else if (closestNode === closestNode.root) {
                return isAfter ? exports.ClosestPosition.InnerAfter : exports.ClosestPosition.InnerBefore;
            }
            else {
                if (!closestNode.allowSibling(this.dragNodes)) {
                    var parentClosestNode = getValidParent(closestNode);
                    if (parentClosestNode) {
                        this.closestNode = parentClosestNode;
                    }
                    if (isInline) {
                        if (parentClosestNode) {
                            if (isAfter) {
                                return exports.ClosestPosition.After;
                            }
                            return exports.ClosestPosition.Before;
                        }
                        return isAfter
                            ? exports.ClosestPosition.ForbidAfter
                            : exports.ClosestPosition.ForbidBefore;
                    }
                    else {
                        if (parentClosestNode) {
                            if (isAfter) {
                                return exports.ClosestPosition.Under;
                            }
                            return exports.ClosestPosition.Upper;
                        }
                        return isAfter
                            ? exports.ClosestPosition.ForbidUnder
                            : exports.ClosestPosition.ForbidUpper;
                    }
                }
                if (isInline) {
                    return isAfter ? exports.ClosestPosition.After : exports.ClosestPosition.Before;
                }
                else {
                    return isAfter ? exports.ClosestPosition.Under : exports.ClosestPosition.Upper;
                }
            }
        };
        Dragon.prototype.setClosestPosition = function (direction) {
            this.closestDirection = direction;
        };
        /**
         * 
         *
         * @readonly
         * @type {TreeNode}
         * @memberof Dragon
         */
        Dragon.prototype.getClosestNode = function (point) {
            var _this = this;
            var _a, _b;
            if (this.touchNode) {
                var touchNodeRect = this.viewport.getValidNodeRect(this.touchNode);
                if (!touchNodeRect)
                    return;
                if ((_b = (_a = this.touchNode) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.length) {
                    var touchDistance = Designable.Shared.calcDistancePointToEdge(point, touchNodeRect);
                    var minDistance_1 = touchDistance;
                    var minDistanceNode_1 = this.touchNode;
                    this.touchNode.eachChildren(function (node) {
                        var rect = _this.viewport.getElementRectById(node.id);
                        if (!rect)
                            return;
                        var distance = Designable.Shared.isPointInRect(point, rect, _this.sensitive)
                            ? 0
                            : Designable.Shared.calcDistanceOfPointToRect(point, rect);
                        if (distance <= minDistance_1) {
                            minDistance_1 = distance;
                            minDistanceNode_1 = node;
                        }
                    });
                    return minDistanceNode_1;
                }
                else {
                    return this.touchNode;
                }
            }
            return null;
        };
        Dragon.prototype.setClosestNode = function (node) {
            this.closestNode = node;
        };
        /**
         * 
         *
         * @readonly
         * @type {DOMRect}
         * @memberof Dragon
         */
        Dragon.prototype.getClosestRect = function () {
            var closestNode = this.closestNode;
            var closestDirection = this.closestDirection;
            if (!closestNode || !closestDirection)
                return;
            var closestRect = this.viewport.getValidNodeRect(closestNode);
            if (closestDirection === exports.ClosestPosition.InnerAfter ||
                closestDirection === exports.ClosestPosition.InnerBefore) {
                return this.viewport.getChildrenRect(closestNode);
            }
            else {
                return closestRect;
            }
        };
        Dragon.prototype.setClosestRect = function (rect) {
            this.closestRect = rect;
        };
        Dragon.prototype.getClosestOffsetRect = function () {
            var closestNode = this.closestNode;
            var closestDirection = this.closestDirection;
            if (!closestNode || !closestDirection)
                return;
            var closestRect = this.viewport.getValidNodeOffsetRect(closestNode);
            if (closestDirection === exports.ClosestPosition.InnerAfter ||
                closestDirection === exports.ClosestPosition.InnerBefore) {
                return this.viewport.getChildrenOffsetRect(closestNode);
            }
            else {
                return closestRect;
            }
        };
        Dragon.prototype.setClosestOffsetRect = function (rect) {
            this.closestOffsetRect = rect;
        };
        Dragon.prototype.setDragNodes = function (dragNodes) {
            if (dragNodes === void 0) { dragNodes = []; }
            this.dragNodes = dragNodes;
            this.trigger(new DragNodeEvent({
                target: this.operation.tree,
                source: dragNodes,
            }));
        };
        Dragon.prototype.setTouchNode = function (node) {
            this.touchNode = node;
            if (!node) {
                this.closestNode = null;
                this.closestDirection = null;
                this.closestOffsetRect = null;
                this.closestRect = null;
            }
        };
        Dragon.prototype.calculate = function (props) {
            var point = props.point, touchNode = props.touchNode, closestNode = props.closestNode, closestDirection = props.closestDirection;
            this.setTouchNode(touchNode);
            this.closestNode = closestNode || this.getClosestNode(point);
            this.closestDirection = closestDirection || this.getClosestPosition(point);
            this.closestRect = this.getClosestRect();
            this.closestOffsetRect = this.getClosestOffsetRect();
        };
        Dragon.prototype.setDropNode = function (node) {
            this.dropNode = node;
            this.trigger(new DropNodeEvent({
                target: this.operation.tree,
                source: node,
            }));
        };
        Dragon.prototype.trigger = function (event) {
            if (this.operation) {
                return this.operation.dispatch(event);
            }
        };
        Dragon.prototype.clear = function () {
            this.dragNodes = [];
            this.touchNode = null;
            this.dropNode = null;
            this.closestNode = null;
            this.closestDirection = null;
            this.closestOffsetRect = null;
            this.closestRect = null;
        };
        Dragon.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                dragNodes: Formily.Reactive.observable.shallow,
                touchNode: Formily.Reactive.observable.ref,
                closestNode: Formily.Reactive.observable.ref,
                closestDirection: Formily.Reactive.observable.ref,
                closestRect: Formily.Reactive.observable.ref,
                setDragNodes: Formily.Reactive.action,
                setTouchNode: Formily.Reactive.action,
                setDropNode: Formily.Reactive.action,
                setClosestNode: Formily.Reactive.action,
                setClosestPosition: Formily.Reactive.action,
                setClosestOffsetRect: Formily.Reactive.action,
                setClosestRect: Formily.Reactive.action,
                clear: Formily.Reactive.action,
                calculate: Formily.Reactive.action,
            });
        };
        return Dragon;
    }());

    var Operation = /** @class */ (function () {
        function Operation(workspace) {
            this.requests = {
                snapshot: null,
            };
            this.engine = workspace.engine;
            this.workspace = workspace;
            this.tree = new TreeNode(__assign(__assign({ componentName: this.engine.props.rootComponentName }, this.engine.props.defaultComponentTree), { operation: this }));
            this.selection = new Selection({
                operation: this,
            });
            this.hover = new Hover({
                operation: this,
            });
            this.outlineDragon = new Dragon({
                operation: this,
                sensitive: false,
                forceBlock: true,
                viewport: this.workspace.outline,
            });
            this.viewportDragon = new Dragon({
                operation: this,
                viewport: this.workspace.viewport,
            });
            this.selection.select(this.tree);
            this.makeObservable();
        }
        Operation.prototype.dispatch = function (event, callback) {
            if (this.workspace.dispatch(event) === false)
                return;
            if (Designable.Shared.isFn(callback))
                return callback();
        };
        Operation.prototype.getSelectedNodes = function () {
            var _this = this;
            return this.selection.selected.map(function (id) { return _this.tree.findById(id); });
        };
        Operation.prototype.setDragNodes = function (nodes) {
            var dragNodes = nodes.reduce(function (buf, node) {
                var _a;
                if (Designable.Shared.isFn((_a = node === null || node === void 0 ? void 0 : node.designerProps) === null || _a === void 0 ? void 0 : _a.getDragNodes)) {
                    var transformed = node.designerProps.getDragNodes(node);
                    return transformed ? buf.concat(transformed) : buf;
                }
                if (node.componentName === '$$ResourceNode$$')
                    return buf.concat(node.children);
                return buf.concat([node]);
            }, []);
            this.outlineDragon.setDragNodes(dragNodes);
            this.viewportDragon.setDragNodes(dragNodes);
        };
        Operation.prototype.getDragNodes = function () {
            var _a;
            if ((_a = this.outlineDragon.dragNodes) === null || _a === void 0 ? void 0 : _a.length) {
                return this.outlineDragon.dragNodes;
            }
            return this.viewportDragon.dragNodes;
        };
        Operation.prototype.getDropNodes = function (parent) {
            var dragNodes = this.getDragNodes();
            return dragNodes.reduce(function (buf, node) {
                var _a;
                if (Designable.Shared.isFn((_a = node.designerProps) === null || _a === void 0 ? void 0 : _a.getDropNodes)) {
                    var cloned = node.isSourceNode ? node.clone(node.parent) : node;
                    var transformed = node.designerProps.getDropNodes(cloned, parent);
                    return transformed ? buf.concat(transformed) : buf;
                }
                if (node.componentName === '$$ResourceNode$$')
                    return buf.concat(node.children);
                return buf.concat([node]);
            }, []);
        };
        Operation.prototype.getClosestNode = function () {
            return this.viewportDragon.closestNode || this.outlineDragon.closestNode;
        };
        Operation.prototype.getClosestPosition = function () {
            return (this.viewportDragon.closestDirection ||
                this.outlineDragon.closestDirection);
        };
        Operation.prototype.setTouchNode = function (node) {
            this.outlineDragon.setTouchNode(node);
            this.viewportDragon.setTouchNode(node);
        };
        Operation.prototype.dragWith = function (point, touchNode) {
            var viewport = this.workspace.viewport;
            var outline = this.workspace.outline;
            if (outline.isPointInViewport(point, false)) {
                this.outlineDragon.calculate({
                    point: point,
                    touchNode: touchNode || this.tree,
                });
                this.viewportDragon.calculate({
                    touchNode: touchNode || this.tree,
                    closestNode: this.outlineDragon.closestNode,
                    closestDirection: this.outlineDragon.closestDirection,
                });
            }
            else if (viewport.isPointInViewport(point, false)) {
                this.viewportDragon.calculate({
                    point: point,
                    touchNode: touchNode || this.tree,
                });
                this.outlineDragon.calculate({
                    touchNode: touchNode || this.tree,
                    closestNode: this.viewportDragon.closestNode,
                    closestDirection: this.viewportDragon.closestDirection,
                });
            }
            else {
                this.setTouchNode(null);
            }
        };
        Operation.prototype.dragClean = function () {
            this.outlineDragon.clear();
            this.viewportDragon.clear();
        };
        Operation.prototype.getTouchNode = function () {
            return this.outlineDragon.touchNode || this.viewportDragon.touchNode;
        };
        Operation.prototype.setDropNode = function (node) {
            this.outlineDragon.setDropNode(node);
            this.viewportDragon.setDropNode(node);
        };
        Operation.prototype.getDropNode = function () {
            return this.outlineDragon.dropNode || this.viewportDragon.dropNode;
        };
        Operation.prototype.removeNodes = function (nodes) {
            for (var i = nodes.length - 1; i >= 0; i--) {
                var node = nodes[i];
                if (node.allowDelete()) {
                    var previous = node.previous;
                    var next = node.next;
                    node.remove();
                    this.selection.select(previous ? previous : next ? next : node.parent);
                    this.hover.clear();
                }
            }
        };
        Operation.prototype.sortNodes = function (nodes) {
            return nodes.sort(function (before, after) {
                if (before.depth !== after.depth)
                    return 0;
                return before.index - after.index >= 0 ? 1 : -1;
            });
        };
        Operation.prototype.cloneNodes = function (nodes) {
            var _this = this;
            var groups = {};
            var lastGroupNode = {};
            var filterNestedNode = this.sortNodes(nodes).filter(function (node) {
                return !nodes.some(function (parent) {
                    return node.isMyParents(parent);
                });
            });
            Designable.Shared.each(filterNestedNode, function (node) {
                var _a, _b, _c, _d, _e, _f, _g;
                if (node === node.root)
                    return;
                if (!node.allowClone())
                    return;
                groups[(_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.id] = groups[(_b = node === null || node === void 0 ? void 0 : node.parent) === null || _b === void 0 ? void 0 : _b.id] || [];
                groups[(_c = node === null || node === void 0 ? void 0 : node.parent) === null || _c === void 0 ? void 0 : _c.id].push(node);
                if (lastGroupNode[(_d = node === null || node === void 0 ? void 0 : node.parent) === null || _d === void 0 ? void 0 : _d.id]) {
                    if (node.index > lastGroupNode[(_e = node === null || node === void 0 ? void 0 : node.parent) === null || _e === void 0 ? void 0 : _e.id].index) {
                        lastGroupNode[(_f = node === null || node === void 0 ? void 0 : node.parent) === null || _f === void 0 ? void 0 : _f.id] = node;
                    }
                }
                else {
                    lastGroupNode[(_g = node === null || node === void 0 ? void 0 : node.parent) === null || _g === void 0 ? void 0 : _g.id] = node;
                }
            });
            var parents = new Map();
            Designable.Shared.each(groups, function (nodes, parentId) {
                var lastNode = lastGroupNode[parentId];
                var insertPoint = lastNode;
                Designable.Shared.each(nodes, function (node) {
                    var cloned = node.clone();
                    if (!cloned)
                        return;
                    if (_this.selection.has(node) &&
                        insertPoint.parent.allowAppend([cloned])) {
                        insertPoint.insertAfter(cloned);
                        insertPoint = insertPoint.next;
                    }
                    else if (_this.selection.length === 1) {
                        var targetNode = _this.tree.findById(_this.selection.first);
                        var cloneNodes = parents.get(targetNode);
                        if (!cloneNodes) {
                            cloneNodes = [];
                            parents.set(targetNode, cloneNodes);
                        }
                        if (targetNode && targetNode.allowAppend([cloned])) {
                            cloneNodes.push(cloned);
                        }
                    }
                });
            });
            parents.forEach(function (nodes, target) {
                if (!nodes.length)
                    return;
                target.append.apply(target, __spread(nodes));
            });
        };
        Operation.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                hover: Formily.Reactive.observable.ref,
                removeNodes: Formily.Reactive.action,
                cloneNodes: Formily.Reactive.action,
            });
        };
        Operation.prototype.snapshot = function (type) {
            var _this = this;
            Designable.Shared.cancelIdle(this.requests.snapshot);
            if (!this.workspace ||
                !this.workspace.history ||
                this.workspace.history.locking)
                return;
            this.requests.snapshot = Designable.Shared.requestIdle(function () {
                _this.workspace.history.push(type);
            });
        };
        Operation.prototype.from = function (operation) {
            if (!operation)
                return;
            if (operation.tree) {
                this.tree.from(operation.tree);
            }
            if (operation.selected) {
                this.selection.selected = operation.selected;
            }
        };
        Operation.prototype.serialize = function () {
            return {
                tree: this.tree.serialize(),
                selected: [this.tree.id],
            };
        };
        return Operation;
    }());

    var History = /** @class */ (function () {
        function History(context, props) {
            this.current = 0;
            this.history = [];
            this.updateTimer = null;
            this.maxSize = 100;
            this.locking = false;
            this.context = context;
            this.props = props;
            this.push();
            this.makeObservable();
        }
        History.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                current: Formily.Reactive.observable.ref,
                history: Formily.Reactive.observable.shallow,
                push: Formily.Reactive.action,
                undo: Formily.Reactive.action,
                redo: Formily.Reactive.action,
                goTo: Formily.Reactive.action,
                clear: Formily.Reactive.action,
            });
        };
        History.prototype.list = function () {
            return this.history;
        };
        History.prototype.push = function (type) {
            var _a;
            if (this.locking)
                return;
            if (this.current < this.history.length - 1) {
                this.history = this.history.slice(0, this.current + 1);
            }
            var item = {
                data: this.context.serialize(),
                timestamp: Date.now(),
                type: type,
            };
            this.current = this.history.length;
            this.history.push(item);
            var overSizeCount = this.history.length - this.maxSize;
            if (overSizeCount > 0) {
                this.history.splice(0, overSizeCount);
                this.current = this.history.length - 1;
            }
            if ((_a = this.props) === null || _a === void 0 ? void 0 : _a.onPush) {
                this.props.onPush(item);
            }
        };
        Object.defineProperty(History.prototype, "allowUndo", {
            get: function () {
                return this.history.length > 0 && this.current - 1 >= 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(History.prototype, "allowRedo", {
            get: function () {
                return this.history.length > this.current + 1;
            },
            enumerable: false,
            configurable: true
        });
        History.prototype.redo = function () {
            var _a;
            if (this.allowRedo) {
                var item = this.history[this.current + 1];
                this.locking = true;
                this.context.from(item.data);
                this.locking = false;
                this.current++;
                if ((_a = this.props) === null || _a === void 0 ? void 0 : _a.onRedo) {
                    this.props.onRedo(item);
                }
            }
        };
        History.prototype.undo = function () {
            var _a;
            if (this.allowUndo) {
                var item = this.history[this.current - 1];
                this.locking = true;
                this.context.from(item.data);
                this.locking = false;
                this.current--;
                if ((_a = this.props) === null || _a === void 0 ? void 0 : _a.onUndo) {
                    this.props.onUndo(item);
                }
            }
        };
        History.prototype.goTo = function (index) {
            var _a;
            var item = this.history[index];
            if (item) {
                this.locking = true;
                this.context.from(item.data);
                this.locking = false;
                this.current = index;
                if ((_a = this.props) === null || _a === void 0 ? void 0 : _a.onGoto) {
                    this.props.onGoto(item);
                }
            }
        };
        History.prototype.clear = function () {
            this.history = [];
            this.current = 0;
        };
        return History;
    }());

    //
    var Workspace = /** @class */ (function () {
        function Workspace(engine, props) {
            var _this = this;
            this.engine = engine;
            this.props = props;
            this.id = props.id || Designable.Shared.uid();
            this.title = props.title;
            this.description = props.description;
            this.viewport = new Viewport({
                engine: this.engine,
                workspace: this,
                viewportElement: props.viewportElement,
                contentWindow: props.contentWindow,
                nodeIdAttrName: this.engine.props.nodeIdAttrName,
            });
            this.outline = new Viewport({
                engine: this.engine,
                workspace: this,
                viewportElement: props.viewportElement,
                contentWindow: props.contentWindow,
                nodeIdAttrName: this.engine.props.outlineNodeIdAttrName,
            });
            this.operation = new Operation(this);
            this.history = new History(this, {
                onPush: function (item) {
                    _this.operation.dispatch(new HistoryPushEvent(item));
                },
                onRedo: function (item) {
                    _this.operation.hover.clear();
                    _this.operation.dispatch(new HistoryRedoEvent(item));
                },
                onUndo: function (item) {
                    _this.operation.hover.clear();
                    _this.operation.dispatch(new HistoryUndoEvent(item));
                },
                onGoto: function (item) {
                    _this.operation.hover.clear();
                    _this.operation.dispatch(new HistoryGotoEvent(item));
                },
            });
        }
        Workspace.prototype.getEventContext = function () {
            return {
                workbench: this.engine.workbench,
                workspace: this,
                engine: this.engine,
                viewport: this.viewport,
            };
        };
        Workspace.prototype.attachEvents = function (container, contentWindow) {
            this.engine.attachEvents(container, contentWindow, this.getEventContext());
        };
        Workspace.prototype.detachEvents = function (container) {
            this.engine.detachEvents(container);
        };
        Workspace.prototype.dispatch = function (event) {
            return this.engine.dispatch(event, this.getEventContext());
        };
        Workspace.prototype.serialize = function () {
            return {
                id: this.id,
                title: this.title,
                description: this.description,
                operation: this.operation.serialize(),
            };
        };
        Workspace.prototype.from = function (workspace) {
            if (!workspace)
                return;
            if (workspace.operation) {
                this.operation.from(workspace.operation);
            }
            if (workspace.id) {
                this.id = workspace.id;
            }
            if (workspace.title) {
                this.title = workspace.title;
            }
            if (workspace.description) {
                this.description = workspace.description;
            }
        };
        return Workspace;
    }());

    var Workbench = /** @class */ (function () {
        function Workbench(engine) {
            this.type = 'DESIGNABLE';
            this.engine = engine;
            this.workspaces = [];
            this.currentWorkspace = null;
            this.activeWorkspace = null;
            this.makeObservable();
        }
        Workbench.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                currentWorkspace: Formily.Reactive.observable.ref,
                workspaces: Formily.Reactive.observable.shallow,
                activeWorkspace: Formily.Reactive.observable.ref,
                type: Formily.Reactive.observable.ref,
                switchWorkspace: Formily.Reactive.action,
                addWorkspace: Formily.Reactive.action,
                removeWorkspace: Formily.Reactive.action,
                setActiveWorkspace: Formily.Reactive.action,
                setWorkbenchType: Formily.Reactive.action,
            });
        };
        Workbench.prototype.getEventContext = function () {
            return {
                engine: this.engine,
                workbench: this.engine.workbench,
                workspace: null,
                viewport: null,
            };
        };
        Workbench.prototype.switchWorkspace = function (id) {
            var finded = this.findWorkspaceById(id);
            if (finded) {
                this.currentWorkspace = finded;
                this.engine.dispatch(new SwitchWorkspaceEvent(finded));
            }
            return this.currentWorkspace;
        };
        Workbench.prototype.setActiveWorkspace = function (workspace) {
            this.activeWorkspace = workspace;
            return workspace;
        };
        Workbench.prototype.setWorkbenchType = function (type) {
            this.type = type;
        };
        Workbench.prototype.addWorkspace = function (props) {
            var finded = this.findWorkspaceById(props.id);
            if (!finded) {
                this.currentWorkspace = new Workspace(this.engine, props);
                this.workspaces.push(this.currentWorkspace);
                this.engine.dispatch(new AddWorkspaceEvent(this.currentWorkspace));
                return this.currentWorkspace;
            }
            return finded;
        };
        Workbench.prototype.removeWorkspace = function (id) {
            var findIndex = this.findWorkspaceIndexById(id);
            if (findIndex > -1 && findIndex < this.workspaces.length) {
                var findedWorkspace = this.workspaces[findIndex];
                findedWorkspace.viewport.detachEvents();
                this.workspaces.splice(findIndex, 1);
                if (findedWorkspace === this.currentWorkspace) {
                    if (this.workspaces.length && this.workspaces[findIndex]) {
                        this.currentWorkspace = this.workspaces[findIndex];
                    }
                    else {
                        this.currentWorkspace = this.workspaces[this.workspaces.length - 1];
                    }
                }
                this.engine.dispatch(new RemoveWorkspaceEvent(findedWorkspace));
            }
        };
        Workbench.prototype.ensureWorkspace = function (props) {
            if (props === void 0) { props = {}; }
            var workspace = this.findWorkspaceById(props.id);
            if (workspace)
                return workspace;
            this.addWorkspace(props);
            return this.currentWorkspace;
        };
        Workbench.prototype.findWorkspaceById = function (id) {
            return this.workspaces.find(function (item) { return item.id === id; });
        };
        Workbench.prototype.findWorkspaceIndexById = function (id) {
            return this.workspaces.findIndex(function (item) { return item.id === id; });
        };
        Workbench.prototype.mapWorkspace = function (callbackFn) {
            return this.workspaces.map(callbackFn);
        };
        Workbench.prototype.eachWorkspace = function (callbackFn) {
            this.workspaces.forEach(callbackFn);
        };
        return Workbench;
    }());

    exports.CursorStatus = void 0;
    (function (CursorStatus) {
        CursorStatus["Normal"] = "NORMAL";
        CursorStatus["DragStart"] = "DRAG_START";
        CursorStatus["Dragging"] = "DRAGGING";
        CursorStatus["DragStop"] = "DRAG_STOP";
    })(exports.CursorStatus || (exports.CursorStatus = {}));
    exports.CursorType = void 0;
    (function (CursorType) {
        CursorType["Move"] = "MOVE";
        CursorType["Selection"] = "SELECTION";
    })(exports.CursorType || (exports.CursorType = {}));
    var DEFAULT_POSITION = {
        pageX: 0,
        pageY: 0,
        clientX: 0,
        clientY: 0,
        topPageX: 0,
        topPageY: 0,
        topClientX: 0,
        topClientY: 0,
    };
    var DEFAULT_SCROLL_OFFSET = {
        scrollX: 0,
        scrollY: 0,
    };
    var setCursorStyle = function (contentWindow, style) {
        var _a, _b, _c, _d;
        var currentRoot = (_b = (_a = document === null || document === void 0 ? void 0 : document.getElementsByTagName) === null || _a === void 0 ? void 0 : _a.call(document, 'html')) === null || _b === void 0 ? void 0 : _b[0];
        var root = (_d = (_c = contentWindow === null || contentWindow === void 0 ? void 0 : contentWindow.document) === null || _c === void 0 ? void 0 : _c.getElementsByTagName('html')) === null || _d === void 0 ? void 0 : _d[0];
        if (root && root.style.cursor !== style) {
            root.style.cursor = style;
        }
        if (currentRoot && currentRoot.style.cursor !== style) {
            currentRoot.style.cursor = style;
        }
    };
    var Cursor = /** @class */ (function () {
        function Cursor(engine) {
            this.type = exports.CursorType.Move;
            this.status = exports.CursorStatus.Normal;
            this.position = DEFAULT_POSITION;
            this.dragStartPosition = DEFAULT_POSITION;
            this.dragStartScrollOffset = DEFAULT_SCROLL_OFFSET;
            this.dragEndPosition = DEFAULT_POSITION;
            this.dragEndScrollOffset = DEFAULT_SCROLL_OFFSET;
            this.view = Designable.Shared.globalThisPolyfill;
            this.engine = engine;
            this.makeObservable();
        }
        Cursor.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                type: Formily.Reactive.observable.ref,
                status: Formily.Reactive.observable.ref,
                position: Formily.Reactive.observable.ref,
                dragStartPosition: Formily.Reactive.observable.ref,
                dragStartScrollOffset: Formily.Reactive.observable.ref,
                dragEndPosition: Formily.Reactive.observable.ref,
                dragEndScrollOffset: Formily.Reactive.observable.ref,
                view: Formily.Reactive.observable.ref,
                setStyle: Formily.Reactive.action,
                setPosition: Formily.Reactive.action,
                setStatus: Formily.Reactive.action,
                setType: Formily.Reactive.action,
            });
        };
        Cursor.prototype.setStatus = function (status) {
            this.status = status;
        };
        Cursor.prototype.setType = function (type) {
            this.type = type;
        };
        Cursor.prototype.setStyle = function (style) {
            this.engine.workbench.eachWorkspace(function (workspace) {
                setCursorStyle(workspace.viewport.contentWindow, style);
            });
        };
        Cursor.prototype.setPosition = function (position) {
            this.position = __assign(__assign({}, this.position), position);
        };
        Cursor.prototype.setDragStartPosition = function (position) {
            this.dragStartPosition = __assign(__assign({}, this.dragStartPosition), position);
        };
        Cursor.prototype.setDragEndPosition = function (position) {
            this.dragEndPosition = __assign(__assign({}, this.dragEndPosition), position);
        };
        Cursor.prototype.setDragStartScrollOffset = function (offset) {
            this.dragStartScrollOffset = __assign(__assign({}, this.dragStartScrollOffset), offset);
        };
        Cursor.prototype.setDragEndScrollOffset = function (offset) {
            this.dragEndScrollOffset = __assign(__assign({}, this.dragEndScrollOffset), offset);
        };
        return Cursor;
    }());

    const _global_Designable_Shared_KeyCode = Designable.Shared.KeyCode;
    var Shortcut = /** @class */ (function () {
        function Shortcut(props) {
            this.codes = this.parseCodes(props.codes);
            this.handler = props.handler;
            this.matcher = props.matcher;
        }
        Shortcut.prototype.parseCodes = function (codes) {
            var results = [];
            codes.forEach(function (code) {
                if (Array.isArray(code)) {
                    results.push(code);
                }
                else {
                    results.push([code]);
                }
            });
            return results;
        };
        Shortcut.prototype.preventCodes = function (codes) {
            if (this.codes.length) {
                for (var i = 0; i < codes.length; i++) {
                    var sequence = this.codes[i];
                    for (var j = 0; j < sequence.length; j++) {
                        if (!Shortcut.matchCode(codes[j], sequence[j])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return false;
        };
        Shortcut.prototype.matched = function (matched, context) {
            if (Designable.Shared.isFn(this.handler) && matched) {
                this.handler(context);
            }
            return matched;
        };
        Shortcut.prototype.match = function (codes, context) {
            var _this = this;
            return this.codes.some(function (sequence) {
                var sortedSelf = Shortcut.sortCodes(sequence);
                var sortedTarget = Shortcut.sortCodes(codes);
                if (Designable.Shared.isFn(_this.matcher)) {
                    return _this.matched(_this.matcher(sortedTarget), context);
                }
                if (sortedTarget.length !== sortedSelf.length)
                    return _this.matched(false, context);
                for (var i = 0; i < sortedSelf.length; i++) {
                    if (!Shortcut.matchCode(sortedTarget[i], sortedSelf[i])) {
                        return _this.matched(false, context);
                    }
                }
                return _this.matched(true, context);
            });
        };
        Shortcut.matchCode = function (code1, code2) {
            var _a, _b;
            return ((_a = code1 === null || code1 === void 0 ? void 0 : code1.toLocaleLowerCase) === null || _a === void 0 ? void 0 : _a.call(code1)) === ((_b = code2 === null || code2 === void 0 ? void 0 : code2.toLocaleLowerCase) === null || _b === void 0 ? void 0 : _b.call(code2));
        };
        Shortcut.sortCodes = function (codes) {
            return codes.map(function (code) { return code.toLocaleLowerCase(); }).sort();
        };
        return Shortcut;
    }());

    var Modifiers = [
        ['metaKey', Designable.Shared.KeyCode.Meta],
        ['shiftKey', Designable.Shared.KeyCode.Shift],
        ['ctrlKey', Designable.Shared.KeyCode.Control],
        ['altKey', Designable.Shared.KeyCode.Alt],
    ];
    var Keyboard = /** @class */ (function () {
        function Keyboard(engine) {
            var _a;
            this.shortcuts = [];
            this.sequence = [];
            this.keyDown = null;
            this.modifiers = {};
            this.requestTimer = null;
            this.engine = engine;
            this.shortcuts = ((_a = engine.props) === null || _a === void 0 ? void 0 : _a.shortcuts) || [];
            this.makeObservable();
        }
        Keyboard.prototype.matchCodes = function (context) {
            for (var i = 0; i < this.shortcuts.length; i++) {
                var shortcut = this.shortcuts[i];
                if (shortcut.match(this.sequence, context)) {
                    return true;
                }
            }
            return false;
        };
        Keyboard.prototype.preventCodes = function () {
            var _this = this;
            return this.shortcuts.some(function (shortcut) {
                return shortcut.preventCodes(_this.sequence);
            });
        };
        Keyboard.prototype.includes = function (key) {
            return this.sequence.some(function (code) { return Shortcut.matchCode(code, key); });
        };
        Keyboard.prototype.excludes = function (key) {
            this.sequence = this.sequence.filter(function (code) { return !Shortcut.matchCode(key, code); });
        };
        Keyboard.prototype.addKeyCode = function (key) {
            if (!this.includes(key)) {
                this.sequence.push(key);
            }
        };
        Keyboard.prototype.removeKeyCode = function (key) {
            if (this.includes(key)) {
                this.excludes(key);
            }
        };
        Keyboard.prototype.isModifier = function (code) {
            return Modifiers.some(function (modifier) { return Shortcut.matchCode(modifier[1], code); });
        };
        Keyboard.prototype.handleModifiers = function (event) {
            var _this = this;
            Modifiers.forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], code = _b[1];
                if (event[key]) {
                    if (!_this.includes(code)) {
                        _this.sequence = [code].concat(_this.sequence);
                    }
                }
            });
        };
        Keyboard.prototype.handleKeyboard = function (event, context) {
            if (event.eventType === 'keydown') {
                this.keyDown = event.data;
                this.addKeyCode(this.keyDown);
                this.handleModifiers(event);
                if (this.matchCodes(context)) {
                    this.sequence = [];
                }
                this.requestClean();
                if (this.preventCodes()) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
            else {
                this.keyDown = null;
            }
        };
        Keyboard.prototype.isKeyDown = function (code) {
            return this.keyDown === code;
        };
        Keyboard.prototype.requestClean = function () {
            var _this = this;
            clearTimeout(this.requestTimer);
            this.requestTimer = setTimeout(function () {
                _this.keyDown = null;
                _this.sequence = [];
                clearTimeout(_this.requestTimer);
            }, 4000);
        };
        Keyboard.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                sequence: Formily.Reactive.observable.shallow,
                keyDown: Formily.Reactive.observable.ref,
                handleKeyboard: Formily.Reactive.action,
            });
        };
        return Keyboard;
    }());

    exports.ScreenType = void 0;
    (function (ScreenType) {
        ScreenType["PC"] = "PC";
        ScreenType["Responsive"] = "Responsive";
        ScreenType["Mobile"] = "Mobile";
        ScreenType["Sketch"] = "Sketch";
    })(exports.ScreenType || (exports.ScreenType = {}));
    exports.ScreenStatus = void 0;
    (function (ScreenStatus) {
        ScreenStatus["Normal"] = "Normal";
        ScreenStatus["Resizing"] = "Resizing";
        ScreenStatus["Zooming"] = "Zooming";
    })(exports.ScreenStatus || (exports.ScreenStatus = {}));
    var Screen = /** @class */ (function () {
        function Screen(engine) {
            this.scale = 1;
            this.width = '100%';
            this.height = '100%';
            this.background = '';
            this.flip = false;
            this.status = exports.ScreenStatus.Normal;
            this.engine = engine;
            this.type = engine.props.defaultScreenType;
            this.makeObservable();
        }
        Screen.prototype.makeObservable = function () {
            Formily.Reactive.define(this, {
                type: Formily.Reactive.observable.ref,
                scale: Formily.Reactive.observable.ref,
                width: Formily.Reactive.observable.ref,
                height: Formily.Reactive.observable.ref,
                status: Formily.Reactive.observable.ref,
                flip: Formily.Reactive.observable.ref,
                background: Formily.Reactive.observable.ref,
                setType: Formily.Reactive.action,
                setScale: Formily.Reactive.action,
                setSize: Formily.Reactive.action,
                resetSize: Formily.Reactive.action,
                setBackground: Formily.Reactive.action,
                setFlip: Formily.Reactive.action,
            });
        };
        Screen.prototype.setStatus = function (status) {
            this.status = status;
        };
        Screen.prototype.setType = function (type) {
            this.type = type;
        };
        Screen.prototype.setScale = function (scale) {
            this.scale = scale;
        };
        Screen.prototype.setSize = function (width, height) {
            if (width) {
                this.width = width;
            }
            if (height) {
                this.height = height;
            }
        };
        Screen.prototype.resetSize = function () {
            this.width = '100%';
            this.height = '100%';
        };
        Screen.prototype.setBackground = function (background) {
            this.background = background;
        };
        Screen.prototype.setFlip = function (flip) {
            this.flip = flip;
        };
        return Screen;
    }());

    /**
     * 
     */
    var Engine = /** @class */ (function (_super) {
        __extends(Engine, _super);
        function Engine(props) {
            var _this = _super.call(this, props) || this;
            _this.props = __assign(__assign({}, Engine.defaultProps), props);
            _this.init();
            _this.id = Designable.Shared.uid();
            return _this;
        }
        Engine.prototype.init = function () {
            this.workbench = new Workbench(this);
            this.screen = new Screen(this);
            this.cursor = new Cursor(this);
            this.keyboard = new Keyboard(this);
        };
        Engine.prototype.setCurrentTree = function (tree) {
            if (this.workbench.currentWorkspace) {
                this.workbench.currentWorkspace.operation.tree.from(tree);
            }
        };
        Engine.prototype.getCurrentTree = function () {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.workbench) === null || _a === void 0 ? void 0 : _a.currentWorkspace) === null || _b === void 0 ? void 0 : _b.operation) === null || _c === void 0 ? void 0 : _c.tree;
        };
        Engine.prototype.getAllSelectedNodes = function () {
            var results = [];
            for (var i = 0; i < this.workbench.workspaces.length; i++) {
                var workspace = this.workbench.workspaces[i];
                results = results.concat(workspace.operation.getSelectedNodes());
            }
            return results;
        };
        Engine.prototype.findNodeById = function (id) {
            return TreeNode.findById(id);
        };
        Engine.prototype.findDraggingNodes = function () {
            var results = [];
            this.workbench.eachWorkspace(function (workspace) {
                var _a;
                (_a = workspace.operation.viewportDragon.dragNodes) === null || _a === void 0 ? void 0 : _a.forEach(function (node) {
                    if (!results.includes(node)) {
                        results.push(node);
                    }
                });
            });
            return results;
        };
        Engine.prototype.createNode = function (node, parent) {
            return new TreeNode(node, parent);
        };
        Engine.prototype.mount = function () {
            this.attachEvents(Designable.Shared.globalThisPolyfill);
        };
        Engine.prototype.unmount = function () {
            this.detachEvents();
        };
        Engine.defaultProps = {
            shortcuts: [],
            effects: [],
            drivers: [],
            rootComponentName: 'Root',
            sourceIdAttrName: 'data-designer-source-id',
            nodeIdAttrName: 'data-designer-node-id',
            contentEditableAttrName: 'data-content-editable',
            contentEditableNodeIdAttrName: 'data-content-editable-node-id',
            clickStopPropagationAttrName: 'data-click-stop-propagation',
            nodeSelectionIdAttrName: 'data-designer-node-helpers-id',
            nodeDragHandlerAttrName: 'data-designer-node-handler',
            nodeResizeHandlerAttrName: 'data-designer-node-resize-handler',
            outlineNodeIdAttrName: 'data-designer-outline-node-id',
            nodeTranslateAttrName: 'data-designer-node-translate-handler',
            defaultScreenType: exports.ScreenType.PC,
        };
        return Engine;
    }(Designable.Shared.Event));

    var useCursorEffect = function (engine) {
        engine.subscribeTo(MouseMoveEvent, function (event) {
            engine.cursor.setStatus(engine.cursor.status === exports.CursorStatus.Dragging ||
                engine.cursor.status === exports.CursorStatus.DragStart
                ? engine.cursor.status
                : exports.CursorStatus.Normal);
            engine.cursor.setPosition(event.data);
        });
        engine.subscribeTo(DragStartEvent, function (event) {
            engine.cursor.setStatus(exports.CursorStatus.DragStart);
            engine.cursor.setDragStartPosition(event.data);
        });
        engine.subscribeTo(DragMoveEvent, function () {
            engine.cursor.setStatus(exports.CursorStatus.Dragging);
        });
        engine.subscribeTo(DragStopEvent, function (event) {
            engine.cursor.setStatus(exports.CursorStatus.DragStop);
            engine.cursor.setDragEndPosition(event.data);
            Designable.Shared.requestIdle(function () {
                engine.cursor.setStatus(exports.CursorStatus.Normal);
            });
        });
        engine.subscribeTo(MouseMoveEvent, function (event) {
            var _a, _b;
            var currentWorkspace = (_a = event === null || event === void 0 ? void 0 : event.context) === null || _a === void 0 ? void 0 : _a.workspace;
            if (!currentWorkspace)
                return;
            var operation = currentWorkspace.operation;
            if (engine.cursor.status !== exports.CursorStatus.Normal) {
                operation.hover.clear();
                return;
            }
            var target = event.data.target;
            var el = (_b = target === null || target === void 0 ? void 0 : target.closest) === null || _b === void 0 ? void 0 : _b.call(target, "\n      *[" + engine.props.nodeIdAttrName + "],\n      *[" + engine.props.outlineNodeIdAttrName + "]\n    ");
            if (!(el === null || el === void 0 ? void 0 : el.getAttribute)) {
                return;
            }
            var nodeId = el.getAttribute(engine.props.nodeIdAttrName);
            var outlineNodeId = el.getAttribute(engine.props.outlineNodeIdAttrName);
            var node = operation.tree.findById(nodeId || outlineNodeId);
            if (node) {
                operation.hover.setHover(node);
            }
            else {
                operation.hover.clear();
            }
        });
    };

    var useViewportEffect = function (engine) {
        engine.subscribeTo(ViewportResizeEvent, function (event) {
            var _a;
            var currentWorkspace = (_a = event === null || event === void 0 ? void 0 : event.context) === null || _a === void 0 ? void 0 : _a.workspace;
            if (!currentWorkspace)
                return;
            var viewport = currentWorkspace.viewport;
            var outline = currentWorkspace.outline;
            if (viewport.matchViewport(event.data.target)) {
                viewport.digestViewport();
            }
            if (outline.matchViewport(event.data.target)) {
                outline.digestViewport();
            }
        });
        engine.subscribeTo(ViewportScrollEvent, function (event) {
            var _a;
            var currentWorkspace = (_a = event === null || event === void 0 ? void 0 : event.context) === null || _a === void 0 ? void 0 : _a.workspace;
            if (!currentWorkspace)
                return;
            var viewport = currentWorkspace.viewport;
            var outline = currentWorkspace.outline;
            if (viewport.matchViewport(event.data.target)) {
                viewport.digestViewport();
            }
            if (outline.matchViewport(event.data.target)) {
                outline.digestViewport();
            }
        });
    };

    var useDragDropEffect = function (engine) {
        engine.subscribeTo(DragStartEvent, function (event) {
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            var target = event.data.target;
            var el = target === null || target === void 0 ? void 0 : target.closest("\n       *[" + engine.props.nodeIdAttrName + "],\n       *[" + engine.props.sourceIdAttrName + "],\n       *[" + engine.props.outlineNodeIdAttrName + "]\n      ");
            var handler = target === null || target === void 0 ? void 0 : target.closest("*[" + engine.props.nodeDragHandlerAttrName + "]");
            var helper = handler === null || handler === void 0 ? void 0 : handler.closest("*[" + engine.props.nodeSelectionIdAttrName + "]");
            if (!(el === null || el === void 0 ? void 0 : el.getAttribute) && !handler)
                return;
            var sourceId = el === null || el === void 0 ? void 0 : el.getAttribute(engine.props.sourceIdAttrName);
            var outlineId = el === null || el === void 0 ? void 0 : el.getAttribute(engine.props.outlineNodeIdAttrName);
            var handlerId = helper === null || helper === void 0 ? void 0 : helper.getAttribute(engine.props.nodeSelectionIdAttrName);
            var nodeId = el === null || el === void 0 ? void 0 : el.getAttribute(engine.props.nodeIdAttrName);
            engine.workbench.eachWorkspace(function (currentWorkspace) {
                var operation = currentWorkspace.operation;
                if (nodeId || outlineId || handlerId) {
                    var node_1 = engine.findNodeById(outlineId || nodeId || handlerId);
                    if (node_1) {
                        if (!node_1.allowDrag())
                            return;
                        if (node_1 === node_1.root)
                            return;
                        var validSelected = engine
                            .getAllSelectedNodes()
                            .filter(function (node) { return node.allowDrag(); });
                        if (validSelected.some(function (selectNode) { return selectNode === node_1; })) {
                            operation.setDragNodes(operation.sortNodes(validSelected));
                        }
                        else {
                            operation.setDragNodes([node_1]);
                        }
                    }
                }
                else if (sourceId) {
                    var sourceNode = engine.findNodeById(sourceId);
                    if (sourceNode) {
                        if (!sourceNode.allowDrag())
                            return;
                        operation.setDragNodes([sourceNode]);
                    }
                }
            });
            engine.cursor.setStyle('move');
        });
        engine.subscribeTo(DragMoveEvent, function (event) {
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            var target = event.data.target;
            var el = target === null || target === void 0 ? void 0 : target.closest("\n      *[" + engine.props.nodeIdAttrName + "],\n      *[" + engine.props.outlineNodeIdAttrName + "]\n    ");
            var nodeId = el === null || el === void 0 ? void 0 : el.getAttribute(engine.props.nodeIdAttrName);
            var outlineId = el === null || el === void 0 ? void 0 : el.getAttribute(engine.props.outlineNodeIdAttrName);
            engine.workbench.eachWorkspace(function (currentWorkspace) {
                var operation = currentWorkspace.operation;
                var tree = operation.tree;
                var point = new Designable.Shared.Point(event.data.topClientX, event.data.topClientY);
                var dragNodes = operation.getDragNodes();
                if (!dragNodes.length)
                    return;
                var touchNode = tree.findById(outlineId || nodeId);
                operation.dragWith(point, touchNode);
            });
        });
        engine.subscribeTo(ViewportScrollEvent, function (event) {
            var _a, _b;
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            var point = new Designable.Shared.Point(engine.cursor.position.topClientX, engine.cursor.position.topClientY);
            var currentWorkspace = (_a = event === null || event === void 0 ? void 0 : event.context) === null || _a === void 0 ? void 0 : _a.workspace;
            if (!currentWorkspace)
                return;
            var operation = currentWorkspace.operation;
            if (!((_b = operation.getDragNodes()) === null || _b === void 0 ? void 0 : _b.length))
                return;
            var tree = operation.tree;
            var viewport = currentWorkspace.viewport;
            var outline = currentWorkspace.outline;
            var viewportTarget = viewport.elementFromPoint(point);
            var outlineTarget = outline.elementFromPoint(point);
            var viewportNodeElement = viewportTarget === null || viewportTarget === void 0 ? void 0 : viewportTarget.closest("\n      *[" + engine.props.nodeIdAttrName + "],\n      *[" + engine.props.outlineNodeIdAttrName + "]\n    ");
            var outlineNodeElement = outlineTarget === null || outlineTarget === void 0 ? void 0 : outlineTarget.closest("\n    *[" + engine.props.nodeIdAttrName + "],\n    *[" + engine.props.outlineNodeIdAttrName + "]\n  ");
            var nodeId = viewportNodeElement === null || viewportNodeElement === void 0 ? void 0 : viewportNodeElement.getAttribute(engine.props.nodeIdAttrName);
            var outlineNodeId = outlineNodeElement === null || outlineNodeElement === void 0 ? void 0 : outlineNodeElement.getAttribute(engine.props.outlineNodeIdAttrName);
            var touchNode = tree.findById(outlineNodeId || nodeId);
            operation.dragWith(point, touchNode);
        });
        engine.subscribeTo(DragStopEvent, function () {
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            engine.workbench.eachWorkspace(function (currentWorkspace) {
                var operation = currentWorkspace.operation;
                var dragNodes = operation.getDragNodes();
                var closestNode = operation.getClosestNode();
                var closestDirection = operation.getClosestPosition();
                var selection = operation.selection;
                if (!dragNodes.length)
                    return;
                if (dragNodes.length && closestNode && closestDirection) {
                    if (closestDirection === exports.ClosestPosition.After ||
                        closestDirection === exports.ClosestPosition.Under) {
                        if (closestNode.allowSibling(dragNodes)) {
                            selection.batchSafeSelect(closestNode.insertAfter.apply(closestNode, __spread(operation.getDropNodes(closestNode.parent))));
                        }
                    }
                    else if (closestDirection === exports.ClosestPosition.Before ||
                        closestDirection === exports.ClosestPosition.Upper) {
                        if (closestNode.allowSibling(dragNodes)) {
                            selection.batchSafeSelect(closestNode.insertBefore.apply(closestNode, __spread(operation.getDropNodes(closestNode.parent))));
                        }
                    }
                    else if (closestDirection === exports.ClosestPosition.Inner ||
                        closestDirection === exports.ClosestPosition.InnerAfter) {
                        if (closestNode.allowAppend(dragNodes)) {
                            selection.batchSafeSelect(closestNode.append.apply(closestNode, __spread(operation.getDropNodes(closestNode))));
                            operation.setDropNode(closestNode);
                        }
                    }
                    else if (closestDirection === exports.ClosestPosition.InnerBefore) {
                        if (closestNode.allowAppend(dragNodes)) {
                            selection.batchSafeSelect(closestNode.prepend.apply(closestNode, __spread(operation.getDropNodes(closestNode))));
                            operation.setDropNode(closestNode);
                        }
                    }
                }
                operation.dragClean();
            });
            engine.cursor.setStyle('');
        });
    };

    var useResizeEffect = function (engine) {
        var findStartNodeHandler = function (target) {
            var handler = target === null || target === void 0 ? void 0 : target.closest("*[" + engine.props.nodeResizeHandlerAttrName + "]");
            if (handler) {
                var type = handler.getAttribute(engine.props.nodeResizeHandlerAttrName);
                if (type) {
                    var element = handler.closest("*[" + engine.props.nodeSelectionIdAttrName + "]");
                    if (element) {
                        var nodeId = element.getAttribute(engine.props.nodeSelectionIdAttrName);
                        if (nodeId) {
                            var node = engine.findNodeById(nodeId);
                            if (node) {
                                var axis = type.includes('x') ? 'x' : 'y';
                                return { axis: axis, type: type, node: node, element: element };
                            }
                        }
                    }
                }
            }
            return;
        };
        var store = {};
        engine.subscribeTo(DragStartEvent, function (event) {
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            var target = event.data.target;
            var data = findStartNodeHandler(target);
            if (data) {
                var point = new Designable.Shared.Point(event.data.clientX, event.data.clientY);
                store.value = __assign(__assign({}, data), { point: point });
                if (data.axis === 'x') {
                    engine.cursor.setStyle('ew-resize');
                }
                else if (data.axis === 'y') {
                    engine.cursor.setStyle('ns-resize');
                }
            }
        });
        engine.subscribeTo(DragMoveEvent, function (event) {
            var _a, _b;
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            if (store.value) {
                var _c = store.value, axis = _c.axis, type = _c.type, node = _c.node, element = _c.element, point = _c.point;
                var allowResize = node.allowResize();
                if (!allowResize)
                    return;
                var resizable = node.designerProps.resizable;
                var rect = element.getBoundingClientRect();
                var current = new Designable.Shared.Point(event.data.clientX, event.data.clientY);
                var plusX = type === 'x-end' ? current.x > point.x : current.x < point.x;
                var plusY = type === 'y-end' ? current.y > point.y : current.y < point.y;
                var allowX = allowResize.includes('x');
                var allowY = allowResize.includes('y');
                var width = (_a = resizable.width) === null || _a === void 0 ? void 0 : _a.call(resizable, node, element);
                var height = (_b = resizable.height) === null || _b === void 0 ? void 0 : _b.call(resizable, node, element);
                if (axis === 'x') {
                    if (plusX && type === 'x-end' && current.x < rect.x + rect.width)
                        return;
                    if (!plusX && type === 'x-end' && current.x > rect.x + rect.width)
                        return;
                    if (plusX && type === 'x-start' && current.x > rect.x)
                        return;
                    if (!plusX && type === 'x-start' && current.x < rect.x)
                        return;
                    if (allowX) {
                        if (plusX) {
                            width.plus();
                        }
                        else {
                            width.minus();
                        }
                    }
                }
                else if (axis === 'y') {
                    if (plusY && type === 'y-end' && current.y < rect.y + rect.height)
                        return;
                    if (!plusY && type === 'y-end' && current.y > rect.y + rect.height)
                        return;
                    if (plusY && type === 'y-start' && current.y > rect.y)
                        return;
                    if (!plusY && type === 'y-start' && current.y < rect.y)
                        return;
                    if (allowY) {
                        if (plusY) {
                            height.plus();
                        }
                        else {
                            height.minus();
                        }
                    }
                }
                store.value.point = current;
            }
        });
        engine.subscribeTo(DragStopEvent, function () {
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            if (store.value) {
                store.value = null;
                engine.cursor.setStyle('');
            }
        });
    };

    var useSelectionEffect = function (engine) {
        engine.subscribeTo(MouseClickEvent, function (event) {
            var _a, _b, _c, _d;
            if (engine.cursor.status !== exports.CursorStatus.Normal)
                return;
            var target = event.data.target;
            var el = (_a = target === null || target === void 0 ? void 0 : target.closest) === null || _a === void 0 ? void 0 : _a.call(target, "\n      *[" + engine.props.nodeIdAttrName + "],\n      *[" + engine.props.outlineNodeIdAttrName + "]\n    ");
            var isHelpers = (_b = target === null || target === void 0 ? void 0 : target.closest) === null || _b === void 0 ? void 0 : _b.call(target, "*[" + engine.props.nodeSelectionIdAttrName + "]");
            var currentWorkspace = (_d = (_c = event.context) === null || _c === void 0 ? void 0 : _c.workspace) !== null && _d !== void 0 ? _d : engine.workbench.activeWorkspace;
            if (!currentWorkspace)
                return;
            if (!(el === null || el === void 0 ? void 0 : el.getAttribute)) {
                var point = new Designable.Shared.Point(event.data.topClientX, event.data.topClientY);
                var operation_1 = currentWorkspace.operation;
                var viewport = currentWorkspace.viewport;
                var outline = currentWorkspace.outline;
                var isInViewport = viewport.isPointInViewport(point, false);
                var isInOutline = outline.isPointInViewport(point, false);
                if (isHelpers)
                    return;
                if (isInViewport || isInOutline) {
                    var selection_1 = operation_1.selection;
                    var tree_1 = operation_1.tree;
                    selection_1.select(tree_1);
                }
                return;
            }
            var nodeId = el.getAttribute(engine.props.nodeIdAttrName);
            var structNodeId = el.getAttribute(engine.props.outlineNodeIdAttrName);
            var operation = currentWorkspace.operation;
            var selection = operation.selection;
            var tree = operation.tree;
            var node = tree.findById(nodeId || structNodeId);
            if (node) {
                engine.keyboard.requestClean();
                if (engine.keyboard.isKeyDown(Designable.Shared.KeyCode.Meta) ||
                    engine.keyboard.isKeyDown(Designable.Shared.KeyCode.Control)) {
                    if (selection.has(node)) {
                        if (selection.selected.length > 1) {
                            selection.remove(node);
                        }
                    }
                    else {
                        selection.add(node);
                    }
                }
                else if (engine.keyboard.isKeyDown(Designable.Shared.KeyCode.Shift)) {
                    if (selection.has(node)) {
                        if (selection.selected.length > 1) {
                            selection.remove(node);
                        }
                    }
                    else {
                        selection.crossAddTo(node);
                    }
                }
                else {
                    selection.select(node);
                }
            }
            else {
                selection.select(tree);
            }
        });
    };

    var useFreeSelectionEffect = function (engine) {
        engine.subscribeTo(DragStopEvent, function (event) {
            if (engine.cursor.type !== exports.CursorType.Selection)
                return;
            engine.workbench.eachWorkspace(function (workspace) {
                var viewport = workspace.viewport;
                var dragStartPoint = new Designable.Shared.Point(engine.cursor.dragStartPosition.topClientX, engine.cursor.dragStartPosition.topClientY);
                var dragStartOffsetPoint = viewport.getOffsetPoint(new Designable.Shared.Point(engine.cursor.dragStartPosition.topClientX, engine.cursor.dragStartPosition.topClientY));
                var dragEndOffsetPoint = viewport.getOffsetPoint(new Designable.Shared.Point(engine.cursor.position.topClientX, engine.cursor.position.topClientY));
                if (!viewport.isPointInViewport(dragStartPoint, false))
                    return;
                var tree = workspace.operation.tree;
                var selectionRect = Designable.Shared.calcRectByStartEndPoint(dragStartOffsetPoint, dragEndOffsetPoint, viewport.scrollX - engine.cursor.dragStartScrollOffset.scrollX, viewport.scrollY - engine.cursor.dragStartScrollOffset.scrollY);
                var selected = [];
                tree.eachChildren(function (node) {
                    var nodeRect = viewport.getValidNodeOffsetRect(node);
                    if (nodeRect && Designable.Shared.isCrossRectInRect(selectionRect, nodeRect)) {
                        selected.push([node, nodeRect]);
                    }
                });
                var selectedNodes = selected.reduce(function (buf, _a) {
                    var _b = __read(_a, 2), node = _b[0], nodeRect = _b[1];
                    if (Designable.Shared.isRectInRect(nodeRect, selectionRect)) {
                        if (selected.some(function (_a) {
                            var _b = __read(_a, 1), selectNode = _b[0];
                            return selectNode.isMyParents(node);
                        })) {
                            return buf;
                        }
                    }
                    return buf.concat(node);
                }, []);
                workspace.operation.selection.batchSafeSelect(selectedNodes);
            });
            engine.cursor.setType(exports.CursorType.Move);
        });
    };

    var useKeyboardEffect = function (engine) {
        engine.subscribeTo(KeyDownEvent, function (event) {
            var keyboard = engine.keyboard;
            if (!keyboard)
                return;
            var workspace = engine.workbench.activeWorkspace || engine.workbench.currentWorkspace;
            keyboard.handleKeyboard(event, workspace.getEventContext());
        });
        engine.subscribeTo(KeyUpEvent, function (event) {
            var keyboard = engine.keyboard;
            if (!keyboard)
                return;
            var workspace = engine.workbench.activeWorkspace || engine.workbench.currentWorkspace;
            keyboard.handleKeyboard(event, workspace.getEventContext());
        });
    };

    var useAutoScrollEffect = function (engine) {
        var xScroller = null;
        var yScroller = null;
        var xScrollerAnimationStop = null;
        var yScrollerAnimationStop = null;
        var scrolling = function (point, viewport) {
            if (engine.cursor.status === exports.CursorStatus.Dragging) {
                xScroller = Designable.Shared.calcAutoScrollBasicInfo(point, 'x', viewport.rect);
                yScroller = Designable.Shared.calcAutoScrollBasicInfo(point, 'y', viewport.rect);
                if (xScroller) {
                    if (xScrollerAnimationStop) {
                        xScrollerAnimationStop();
                    }
                    xScrollerAnimationStop = Designable.Shared.scrollAnimate(viewport.scrollContainer, 'x', xScroller.direction, xScroller.speed);
                }
                else {
                    if (xScrollerAnimationStop) {
                        xScrollerAnimationStop();
                    }
                }
                if (yScroller) {
                    if (yScrollerAnimationStop) {
                        yScrollerAnimationStop();
                    }
                    yScrollerAnimationStop = Designable.Shared.scrollAnimate(viewport.scrollContainer, 'y', yScroller.direction, yScroller.speed);
                }
                else {
                    if (yScrollerAnimationStop) {
                        yScrollerAnimationStop();
                    }
                }
            }
        };
        engine.subscribeTo(DragStartEvent, function (event) {
            if (engine.cursor.type !== exports.CursorType.Move &&
                engine.cursor.type !== exports.CursorType.Selection)
                return;
            engine.workbench.eachWorkspace(function (workspace) {
                var viewport = workspace.viewport;
                var outline = workspace.outline;
                var point = new Designable.Shared.Point(event.data.topClientX, event.data.topClientY);
                if (!viewport.isPointInViewport(point) &&
                    !outline.isPointInViewport(point))
                    return;
                engine.cursor.setDragStartScrollOffset({
                    scrollX: viewport.scrollX,
                    scrollY: viewport.scrollY,
                });
            });
        });
        engine.subscribeTo(DragMoveEvent, function (event) {
            if (engine.cursor.type !== exports.CursorType.Move &&
                engine.cursor.type !== exports.CursorType.Selection)
                return;
            engine.workbench.eachWorkspace(function (workspace) {
                var viewport = workspace.viewport;
                var outline = workspace.outline;
                var point = new Designable.Shared.Point(event.data.topClientX, event.data.topClientY);
                if (outline.isPointInViewport(point)) {
                    scrolling(point, outline);
                }
                else if (viewport.isPointInViewport(point)) {
                    scrolling(point, viewport);
                }
            });
        });
        engine.subscribeTo(DragStopEvent, function () {
            if (engine.cursor.type !== exports.CursorType.Move &&
                engine.cursor.type !== exports.CursorType.Selection)
                return;
            xScroller = null;
            yScroller = null;
            if (xScrollerAnimationStop) {
                xScrollerAnimationStop();
            }
            if (yScrollerAnimationStop) {
                yScrollerAnimationStop();
            }
        });
    };

    var useWorkspaceEffect = function (engine) {
        engine.subscribeWith([
            'append:node',
            'insert:after',
            'insert:before',
            'insert:children',
            'drag:node',
            'drop:node',
            'prepend:node',
            'remove:node',
            'select:node',
            'update:children',
            'wrap:node',
            'update:node:props',
        ], function (event) {
            var _a;
            if ((_a = event.context) === null || _a === void 0 ? void 0 : _a.workbench) {
                engine.workbench.setActiveWorkspace(event.context.workspace);
            }
        });
        engine.subscribeTo(SelectNodeEvent, function (event) {
            engine.workbench.eachWorkspace(function (workspace) {
                if (workspace !== event.context.workspace) {
                    workspace.operation.selection.clear();
                }
            });
        });
    };

    function getAllRanges(sel) {
        var ranges = [];
        for (var i = 0; i < sel.rangeCount; i++) {
            var range = sel.getRangeAt(i);
            ranges[i] = {
                collapsed: range.collapsed,
                startOffset: range.startOffset,
                endOffset: range.endOffset,
            };
        }
        return ranges;
    }
    function setEndOfContenteditable(contentEditableElement) {
        var range = document.createRange();
        range.selectNodeContents(contentEditableElement);
        range.collapse(false);
        var selection = Designable.Shared.globalThisPolyfill.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    }
    function createCaretCache(el) {
        var currentSelection = Designable.Shared.globalThisPolyfill.getSelection();
        if (currentSelection.containsNode(el))
            return;
        var ranges = getAllRanges(currentSelection);
        return function () {
            var sel = Designable.Shared.globalThisPolyfill.getSelection();
            var firstNode = el.childNodes[0];
            if (!firstNode)
                return;
            sel.removeAllRanges();
            ranges.forEach(function (item) {
                var range = document.createRange();
                range.collapse(item.collapsed);
                range.setStart(firstNode, item.startOffset);
                range.setEnd(firstNode, item.endOffset);
                sel.addRange(range);
            });
        };
    }
    var useContentEditableEffect = function (engine) {
        var globalState = {
            activeElements: new Map(),
            queue: [],
            requestTimer: null,
            isComposition: false,
        };
        function onKeyDownHandler(event) {
            if (event.key === 'Enter') {
                event.stopPropagation();
                event.preventDefault();
            }
        }
        function onInputHandler(event) {
            var _this = this;
            var node = globalState.activeElements.get(this);
            event.stopPropagation();
            event.preventDefault();
            if (node) {
                var target_1 = event.target;
                var handler = function () {
                    globalState.queue.length = 0;
                    if (globalState.isComposition)
                        return;
                    var restore = createCaretCache(target_1);
                    Formily.Path.Path.setIn(node.props, _this.getAttribute(engine.props.contentEditableAttrName), target_1 === null || target_1 === void 0 ? void 0 : target_1.textContent);
                    Designable.Shared.requestIdle(function () {
                        node.takeSnapshot('update:node:props');
                        restore();
                    });
                };
                globalState.queue.push(handler);
                clearTimeout(globalState.requestTimer);
                globalState.requestTimer = setTimeout(handler, 600);
            }
        }
        function onSelectionChangeHandler() {
            clearTimeout(globalState.requestTimer);
            globalState.requestTimer = setTimeout(globalState.queue[globalState.queue.length - 1], 600);
        }
        function onCompositionHandler(event) {
            if (event.type === 'compositionend') {
                globalState.isComposition = false;
                onInputHandler(event);
            }
            else {
                clearTimeout(globalState.requestTimer);
                globalState.isComposition = true;
            }
        }
        function onPastHandler(event) {
            event.preventDefault();
            var text = event.clipboardData.getData('text');
            this.textContent = text;
        }
        function findTargetNodeId(element) {
            if (!element)
                return;
            var nodeId = element.getAttribute(engine.props.contentEditableNodeIdAttrName);
            if (nodeId)
                return nodeId;
            var parent = element.closest("*[" + engine.props.nodeIdAttrName + "]");
            if (parent)
                return parent.getAttribute(engine.props.nodeIdAttrName);
        }
        engine.subscribeTo(MouseClickEvent, function (event) {
            var _a;
            var target = event.data.target;
            var editableElement = (_a = target === null || target === void 0 ? void 0 : target.closest) === null || _a === void 0 ? void 0 : _a.call(target, "*[" + engine.props.contentEditableAttrName + "]");
            if (editableElement &&
                editableElement.getAttribute('contenteditable') === 'true')
                return;
            globalState.activeElements.forEach(function (node, element) {
                globalState.activeElements.delete(element);
                element.removeAttribute('contenteditable');
                element.removeAttribute('spellcheck');
                element.removeEventListener('input', onInputHandler);
                element.removeEventListener('compositionstart', onCompositionHandler);
                element.removeEventListener('compositionupdate', onCompositionHandler);
                element.removeEventListener('compositionend', onCompositionHandler);
                element.removeEventListener('past', onPastHandler);
                document.removeEventListener('selectionchange', onSelectionChangeHandler);
            });
        });
        engine.subscribeTo(MouseDoubleClickEvent, function (event) {
            var _a;
            var target = event.data.target;
            var editableElement = (_a = target === null || target === void 0 ? void 0 : target.closest) === null || _a === void 0 ? void 0 : _a.call(target, "*[" + engine.props.contentEditableAttrName + "]");
            var workspace = engine.workbench.activeWorkspace;
            var tree = workspace.operation.tree;
            if (editableElement) {
                var editable = editableElement.getAttribute('contenteditable');
                if (editable === 'false' || !editable) {
                    var nodeId = findTargetNodeId(editableElement);
                    if (nodeId) {
                        var targetNode = tree.findById(nodeId);
                        if (targetNode) {
                            globalState.activeElements.set(editableElement, targetNode);
                            editableElement.setAttribute('spellcheck', 'false');
                            editableElement.setAttribute('contenteditable', 'true');
                            editableElement.focus();
                            editableElement.addEventListener('input', onInputHandler);
                            editableElement.addEventListener('compositionstart', onCompositionHandler);
                            editableElement.addEventListener('compositionupdate', onCompositionHandler);
                            editableElement.addEventListener('compositionend', onCompositionHandler);
                            editableElement.addEventListener('keydown', onKeyDownHandler);
                            editableElement.addEventListener('paste', onPastHandler);
                            document.addEventListener('selectionchange', onSelectionChangeHandler);
                            setEndOfContenteditable(editableElement);
                        }
                    }
                }
            }
        });
    };

    var useTranslateEffect = function (engine) {
        var findStartNodeHandler = function (target) {
            var handler = target === null || target === void 0 ? void 0 : target.closest("*[" + engine.props.nodeTranslateAttrName + "]");
            if (handler) {
                var type = handler.getAttribute(engine.props.nodeTranslateAttrName);
                if (type) {
                    var element = handler.closest("*[" + engine.props.nodeSelectionIdAttrName + "]");
                    if (element) {
                        var nodeId = element.getAttribute(engine.props.nodeSelectionIdAttrName);
                        if (nodeId) {
                            var node = engine.findNodeById(nodeId);
                            if (node) {
                                return { node: node, element: element };
                            }
                        }
                    }
                }
            }
            return;
        };
        var store = {};
        engine.subscribeTo(DragStartEvent, function (event) {
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            var target = event.data.target;
            var data = findStartNodeHandler(target);
            if (data) {
                var point = new Designable.Shared.Point(event.data.clientX, event.data.clientY);
                store.value = __assign(__assign({}, data), { point: point });
            }
        });
        engine.subscribeTo(DragMoveEvent, function (event) {
            var _a, _b;
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            if (store.value) {
                var _c = store.value, node = _c.node, element = _c.element, point = _c.point;
                var allowTranslate = node.allowTranslate();
                if (!allowTranslate)
                    return;
                var translatable = node.designerProps.translatable;
                var current = new Designable.Shared.Point(event.data.clientX, event.data.clientY);
                var diffX = current.x - (point === null || point === void 0 ? void 0 : point.x);
                var diffY = current.y - (point === null || point === void 0 ? void 0 : point.y);
                var horizontal = (_a = translatable.x) === null || _a === void 0 ? void 0 : _a.call(translatable, node, element, diffX);
                var vertical = (_b = translatable.y) === null || _b === void 0 ? void 0 : _b.call(translatable, node, element, diffY);
                horizontal.translate();
                vertical.translate();
                store.value.point = current;
            }
        });
        engine.subscribeTo(DragStopEvent, function () {
            if (engine.cursor.type !== exports.CursorType.Move)
                return;
            if (store.value) {
                store.value = null;
            }
        });
    };

    var SelectNodes = new Shortcut({
        codes: [[_global_Designable_Shared_KeyCode.Meta], [_global_Designable_Shared_KeyCode.Control]],
    });
    var SelectSameTypeNodes = new Shortcut({
        codes: [_global_Designable_Shared_KeyCode.Shift],
    });
    var PreventCommandX = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Meta, _global_Designable_Shared_KeyCode.X],
            [_global_Designable_Shared_KeyCode.Control, _global_Designable_Shared_KeyCode.X],
        ],
    });
    var SelectAllNodes = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Meta, _global_Designable_Shared_KeyCode.A],
            [_global_Designable_Shared_KeyCode.Control, _global_Designable_Shared_KeyCode.A],
        ],
        handler: function (context) {
            var operation = context === null || context === void 0 ? void 0 : context.workspace.operation;
            if (operation) {
                var tree = operation.tree;
                var selection = operation.selection;
                selection.batchSelect(tree.descendants);
            }
        },
    });

    /**
     * 
     */
    var DeleteNodes = new Shortcut({
        codes: [[_global_Designable_Shared_KeyCode.Backspace], [_global_Designable_Shared_KeyCode.Delete]],
        handler: function (context) {
            var operation = context === null || context === void 0 ? void 0 : context.workspace.operation;
            if (operation) {
                operation.removeNodes(operation.getSelectedNodes());
            }
        },
    });
    var Clipboard = {
        nodes: [],
    };
    var CopyNodes = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Meta, _global_Designable_Shared_KeyCode.C],
            [_global_Designable_Shared_KeyCode.Control, _global_Designable_Shared_KeyCode.C],
        ],
        handler: function (context) {
            var operation = context === null || context === void 0 ? void 0 : context.workspace.operation;
            if (operation) {
                Clipboard.nodes = operation.getSelectedNodes();
            }
        },
    });
    var PasteNodes = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Meta, _global_Designable_Shared_KeyCode.V],
            [_global_Designable_Shared_KeyCode.Control, _global_Designable_Shared_KeyCode.V],
        ],
        handler: function (context) {
            var operation = context === null || context === void 0 ? void 0 : context.workspace.operation;
            if (operation) {
                operation.cloneNodes(Clipboard.nodes);
            }
        },
    });

    var UndoMutation = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Meta, _global_Designable_Shared_KeyCode.Z],
            [_global_Designable_Shared_KeyCode.Control, _global_Designable_Shared_KeyCode.Z],
        ],
        handler: function (context) {
            var workspace = context === null || context === void 0 ? void 0 : context.workspace;
            if (workspace) {
                workspace.history.undo();
            }
            workspace.operation.hover.clear();
        },
    });
    var RedoMutation = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Meta, _global_Designable_Shared_KeyCode.Shift, _global_Designable_Shared_KeyCode.Z],
            [_global_Designable_Shared_KeyCode.Control, _global_Designable_Shared_KeyCode.Shift, _global_Designable_Shared_KeyCode.Z],
        ],
        handler: function (context) {
            var workspace = context === null || context === void 0 ? void 0 : context.workspace;
            if (workspace) {
                workspace.history.redo();
            }
            workspace.operation.hover.clear();
        },
    });

    var CursorSwitchSelection = new Shortcut({
        codes: [_global_Designable_Shared_KeyCode.Shift, _global_Designable_Shared_KeyCode.S],
        handler: function (context) {
            var engine = context === null || context === void 0 ? void 0 : context.engine;
            if (engine) {
                engine.cursor.setType(exports.CursorType.Selection);
            }
        },
    });

    var findBottomLastChild = function (node) {
        if (!node)
            return node;
        if (node.lastChild) {
            return findBottomLastChild(node.lastChild);
        }
        return node;
    };
    var findTopParentNext = function (node) {
        var _a;
        if (!node.parent)
            return node;
        if ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.next)
            return node.parent.next;
        return findTopParentNext(node.parent);
    };
    var SelectPrevNode = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Up],
            [_global_Designable_Shared_KeyCode.PageUp],
            [_global_Designable_Shared_KeyCode.ArrowUp],
            [_global_Designable_Shared_KeyCode.Left],
            [_global_Designable_Shared_KeyCode.LeftWindowKey],
            [_global_Designable_Shared_KeyCode.ArrowLeft],
        ],
        handler: function (context) {
            var operation = context === null || context === void 0 ? void 0 : context.workspace.operation;
            if (operation) {
                var tree = operation.tree;
                var selection = operation.selection;
                var selectedNode = tree.findById(selection.last);
                if (selectedNode) {
                    var previousNode = selectedNode.previous;
                    if (previousNode) {
                        var bottom = findBottomLastChild(previousNode);
                        if (bottom) {
                            selection.select(bottom);
                        }
                        else {
                            selection.select(previousNode);
                        }
                    }
                    else {
                        selection.select(selectedNode.parent);
                    }
                }
            }
        },
    });
    var SelectNextNode = new Shortcut({
        codes: [
            [_global_Designable_Shared_KeyCode.Down],
            [_global_Designable_Shared_KeyCode.PageDown],
            [_global_Designable_Shared_KeyCode.ArrowDown],
            [_global_Designable_Shared_KeyCode.Right],
            [_global_Designable_Shared_KeyCode.RightWindowKey],
            [_global_Designable_Shared_KeyCode.ArrowRight],
        ],
        handler: function (context) {
            var operation = context === null || context === void 0 ? void 0 : context.workspace.operation;
            if (operation) {
                var tree = operation.tree;
                var selection = operation.selection;
                var selectedNode = tree.findById(selection.last);
                if (selectedNode) {
                    var nextNode = selectedNode.firstChild
                        ? selectedNode.firstChild
                        : selectedNode.next;
                    if (nextNode) {
                        selection.select(nextNode);
                    }
                    else {
                        selection.select(findTopParentNext(selectedNode));
                    }
                }
            }
        },
    });

    var DEFAULT_EFFECTS = [
        useCursorEffect,
        useViewportEffect,
        useDragDropEffect,
        useResizeEffect,
        useSelectionEffect,
        useKeyboardEffect,
        useAutoScrollEffect,
        useWorkspaceEffect,
        useFreeSelectionEffect,
        useContentEditableEffect,
        useTranslateEffect,
    ];
    var DEFAULT_DRIVERS = [
        DragDropDriver,
        MouseClickDriver,
        MouseMoveDriver,
        ViewportResizeDriver,
        ViewportScrollDriver,
        KeyboardDriver,
    ];
    var DEFAULT_SHORTCUTS = [
        PreventCommandX,
        SelectNodes,
        SelectAllNodes,
        SelectSameTypeNodes,
        DeleteNodes,
        CopyNodes,
        PasteNodes,
        SelectPrevNode,
        SelectNextNode,
        UndoMutation,
        RedoMutation,
        CursorSwitchSelection,
    ];

    var isBehaviorHost = function (val) {
        return (val === null || val === void 0 ? void 0 : val.Behavior) && isBehaviorList(val.Behavior);
    };
    var isBehaviorList = function (val) {
        return Array.isArray(val) && val.every(isBehavior);
    };
    var isBehavior = function (val) {
        return (val === null || val === void 0 ? void 0 : val.name) || (val === null || val === void 0 ? void 0 : val.selector) || (val === null || val === void 0 ? void 0 : val.extends) || (val === null || val === void 0 ? void 0 : val.designerProps) || (val === null || val === void 0 ? void 0 : val.designerLocales);
    };
    var isResourceHost = function (val) {
        return (val === null || val === void 0 ? void 0 : val.Resource) && isResourceList(val.Resource);
    };
    var isResourceList = function (val) {
        return Array.isArray(val) && val.every(isResource);
    };
    var isResource = function (val) {
        return (val === null || val === void 0 ? void 0 : val.node) && !!val.node.isSourceNode && val.node instanceof TreeNode;
    };
    var createLocales = function () {
        var packages = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            packages[_i] = arguments[_i];
        }
        var results = {};
        packages.forEach(function (locales) {
            mergeLocales(results, locales);
        });
        return results;
    };
    var createBehavior = function () {
        var behaviors = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            behaviors[_i] = arguments[_i];
        }
        return behaviors.reduce(function (buf, behavior) {
            if (Designable.Shared.isArr(behavior))
                return buf.concat(createBehavior.apply(void 0, __spread(behavior)));
            var selector = (behavior || {}).selector;
            if (!selector)
                return buf;
            if (typeof selector === 'string') {
                behavior.selector = function (node) { return node.componentName === selector; };
            }
            return buf.concat(behavior);
        }, []);
    };
    var createResource = function () {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        return sources.reduce(function (buf, source) {
            return buf.concat(__assign(__assign({}, source), { node: new TreeNode({
                    componentName: '$$ResourceNode$$',
                    isSourceNode: true,
                    children: source.elements || [],
                }) }));
        }, []);
    };
    var createDesigner = function (props) {
        if (props === void 0) { props = {}; }
        var drivers = props.drivers || [];
        var effects = props.effects || [];
        var shortcuts = props.shortcuts || [];
        return Formily.Reactive.untracked(function () {
            return new Engine(__assign(__assign({}, props), { effects: __spread(effects, DEFAULT_EFFECTS), drivers: __spread(drivers, DEFAULT_DRIVERS), shortcuts: __spread(shortcuts, DEFAULT_SHORTCUTS) }));
        });
    };

    var Core = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isBehaviorHost: isBehaviorHost,
        isBehaviorList: isBehaviorList,
        isBehavior: isBehavior,
        isResourceHost: isResourceHost,
        isResourceList: isResourceList,
        isResource: isResource,
        createLocales: createLocales,
        createBehavior: createBehavior,
        createResource: createResource,
        createDesigner: createDesigner,
        GlobalRegistry: GlobalRegistry,
        Engine: Engine,
        get ScreenType () { return exports.ScreenType; },
        get ScreenStatus () { return exports.ScreenStatus; },
        Screen: Screen,
        get CursorStatus () { return exports.CursorStatus; },
        get CursorType () { return exports.CursorType; },
        Cursor: Cursor,
        Operation: Operation,
        Viewport: Viewport,
        TreeNode: TreeNode,
        Workbench: Workbench,
        Workspace: Workspace,
        Selection: Selection,
        get ClosestPosition () { return exports.ClosestPosition; },
        Dragon: Dragon,
        Keyboard: Keyboard,
        KeyCode: _global_Designable_Shared_KeyCode,
        Shortcut: Shortcut,
        History: History,
        DragMoveEvent: DragMoveEvent,
        DragStartEvent: DragStartEvent,
        DragStopEvent: DragStopEvent,
        MouseClickEvent: MouseClickEvent,
        MouseDoubleClickEvent: MouseDoubleClickEvent,
        MouseMoveEvent: MouseMoveEvent,
        KeyDownEvent: KeyDownEvent,
        KeyUpEvent: KeyUpEvent,
        DragNodeEvent: DragNodeEvent,
        DropNodeEvent: DropNodeEvent,
        HoverNodeEvent: HoverNodeEvent,
        InsertAfterEvent: InsertAfterEvent,
        InsertBeforeEvent: InsertBeforeEvent,
        InsertChildrenEvent: InsertChildrenEvent,
        PrependNodeEvent: PrependNodeEvent,
        RemoveNodeEvent: RemoveNodeEvent,
        SelectNodeEvent: SelectNodeEvent,
        UnSelectNodeEvent: UnSelectNodeEvent,
        UpdateChildrenEvent: UpdateChildrenEvent,
        UpdateNodePropsEvent: UpdateNodePropsEvent,
        WrapNodeEvent: WrapNodeEvent,
        CloneNodeEvent: CloneNodeEvent,
        AppendNodeEvent: AppendNodeEvent,
        FromNodeEvent: FromNodeEvent,
        ViewportResizeEvent: ViewportResizeEvent,
        ViewportScrollEvent: ViewportScrollEvent,
        AddWorkspaceEvent: AddWorkspaceEvent,
        RemoveWorkspaceEvent: RemoveWorkspaceEvent,
        SwitchWorkspaceEvent: SwitchWorkspaceEvent,
        HistoryUndoEvent: HistoryUndoEvent,
        HistoryRedoEvent: HistoryRedoEvent,
        HistoryGotoEvent: HistoryGotoEvent,
        HistoryPushEvent: HistoryPushEvent
    });

    var _a;

    if ((_a = Designable.Shared.globalThisPolyfill === null || Designable.Shared.globalThisPolyfill === void 0 ? void 0 : Designable.Shared.globalThisPolyfill['Designable']) === null || _a === void 0 ? void 0 : _a['Core']) {
        if (module && module.exports) {
            module.exports = __assign({ __esModule: true }, Designable.Shared.globalThisPolyfill['Designable']['Core']);
        }
    }
    else {
        Designable.Shared.globalThisPolyfill['Designable'] = Designable.Shared.globalThisPolyfill['Designable'] || {};
        Designable.Shared.globalThisPolyfill['Designable'].Core = Core;
    }

    exports.AddWorkspaceEvent = AddWorkspaceEvent;
    exports.AppendNodeEvent = AppendNodeEvent;
    exports.CloneNodeEvent = CloneNodeEvent;
    exports.Cursor = Cursor;
    exports.DragMoveEvent = DragMoveEvent;
    exports.DragNodeEvent = DragNodeEvent;
    exports.DragStartEvent = DragStartEvent;
    exports.DragStopEvent = DragStopEvent;
    exports.Dragon = Dragon;
    exports.DropNodeEvent = DropNodeEvent;
    exports.Engine = Engine;
    exports.FromNodeEvent = FromNodeEvent;
    exports.GlobalRegistry = GlobalRegistry;
    exports.History = History;
    exports.HistoryGotoEvent = HistoryGotoEvent;
    exports.HistoryPushEvent = HistoryPushEvent;
    exports.HistoryRedoEvent = HistoryRedoEvent;
    exports.HistoryUndoEvent = HistoryUndoEvent;
    exports.HoverNodeEvent = HoverNodeEvent;
    exports.InsertAfterEvent = InsertAfterEvent;
    exports.InsertBeforeEvent = InsertBeforeEvent;
    exports.InsertChildrenEvent = InsertChildrenEvent;
    exports.KeyCode = _global_Designable_Shared_KeyCode;
    exports.KeyDownEvent = KeyDownEvent;
    exports.KeyUpEvent = KeyUpEvent;
    exports.Keyboard = Keyboard;
    exports.MouseClickEvent = MouseClickEvent;
    exports.MouseDoubleClickEvent = MouseDoubleClickEvent;
    exports.MouseMoveEvent = MouseMoveEvent;
    exports.Operation = Operation;
    exports.PrependNodeEvent = PrependNodeEvent;
    exports.RemoveNodeEvent = RemoveNodeEvent;
    exports.RemoveWorkspaceEvent = RemoveWorkspaceEvent;
    exports.Screen = Screen;
    exports.SelectNodeEvent = SelectNodeEvent;
    exports.Selection = Selection;
    exports.Shortcut = Shortcut;
    exports.SwitchWorkspaceEvent = SwitchWorkspaceEvent;
    exports.TreeNode = TreeNode;
    exports.UnSelectNodeEvent = UnSelectNodeEvent;
    exports.UpdateChildrenEvent = UpdateChildrenEvent;
    exports.UpdateNodePropsEvent = UpdateNodePropsEvent;
    exports.Viewport = Viewport;
    exports.ViewportResizeEvent = ViewportResizeEvent;
    exports.ViewportScrollEvent = ViewportScrollEvent;
    exports.Workbench = Workbench;
    exports.Workspace = Workspace;
    exports.WrapNodeEvent = WrapNodeEvent;
    exports.createBehavior = createBehavior;
    exports.createDesigner = createDesigner;
    exports.createLocales = createLocales;
    exports.createResource = createResource;
    exports.isBehavior = isBehavior;
    exports.isBehaviorHost = isBehaviorHost;
    exports.isBehaviorList = isBehaviorList;
    exports.isResource = isResource;
    exports.isResourceHost = isResourceHost;
    exports.isResourceList = isResourceList;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
